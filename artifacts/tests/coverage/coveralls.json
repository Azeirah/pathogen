{"service_name":"travis-ci","service_job_id":"10304273","git":{"branch":"(detached from 597b79e)","head":{"id":"597b79e9d28fdf7570355c6c9799dbad229d367a","author_name":"Erin Millard","author_email":"ezzatron@gmail.com","committer_name":"Erin Millard","committer_email":"ezzatron@gmail.com","message":"Fixed typo."},"remotes":[{"name":"origin","url":"git:\/\/github.com\/eloquent\/pathogen.git"}]},"run_at":"2013-08-17 08:24:55 +0000","source_files":[{"name":"Eloquent\/Pathogen\/AbsolutePath.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen;\n\n\/**\n * Represents an absolute path.\n *\/\nclass AbsolutePath extends AbstractPath implements AbsolutePathInterface\n{\n    \/\/ Implementation of PathInterface =========================================\n\n    \/**\n     * Generate a string representation of this path.\n     *\n     * @return string A string representation of this path.\n     *\/\n    public function string()\n    {\n        return static::ATOM_SEPARATOR . parent::string();\n    }\n\n    \/**\n     * Adds a trailing slash to this path.\n     *\n     * @return PathInterface A new path instance with a trailing slash suffixed\n     *     to this path.\n     *\/\n    public function joinTrailingSlash()\n    {\n        if (!$this->hasAtoms()) {\n            return $this;\n        }\n\n        return parent::joinTrailingSlash();\n    }\n\n    \/\/ Implementation of AbsolutePathInterface =================================\n\n    \/**\n     * Determine whether this path is the root path.\n     *\n     * The root path is an absolute path with no atoms.\n     *\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return boolean True if this path is the root path.\n     *\/\n    public function isRoot(\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    ) {\n        return !$this->normalize($normalizer)->hasAtoms();\n    }\n\n    \/**\n     * Determine if this path is the direct parent of the supplied path.\n     *\n     * @param AbsolutePathInterface                   $path       The child path.\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return boolean True if this path is the direct parent of the supplied\n     *     path.\n     *\/\n    public function isParentOf(\n        AbsolutePathInterface $path,\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    ) {\n        if (null === $normalizer) {\n            $normalizer = $this->createDefaultNormalizer();\n        }\n\n        return\n            $path->hasAtoms() &&\n            $this->normalize($normalizer)->atoms() ===\n                $path->parent()->normalize($normalizer)->atoms();\n    }\n\n    \/**\n     * Determine if this path is an ancestor of the supplied path.\n     *\n     * @param AbsolutePathInterface                   $path       The child path.\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return boolean True if this path is an ancestor of the supplied path.\n     *\/\n    public function isAncestorOf(\n        AbsolutePathInterface $path,\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    ) {\n        if (null === $normalizer) {\n            $normalizer = $this->createDefaultNormalizer();\n        }\n\n        $parentAtoms = $this->normalize($normalizer)->atoms();\n\n        return $parentAtoms === array_slice(\n            $path->normalize($normalizer)->atoms(),\n            0,\n            count($parentAtoms)\n        );\n    }\n\n    \/**\n     * Determine the shortest path from the supplied path to this path.\n     *\n     * For example, given path A equal to '\/foo\/bar', and path B equal to\n     * '\/foo\/baz', A relative to B would be '..\/bar'.\n     *\n     * @param AbsolutePathInterface $path The path that the generated path will\n     *     be relative to.\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return RelativePathInterface A relative path from the supplied path to\n     *     this path.\n     *\/\n    public function relativeTo(\n        AbsolutePathInterface $path,\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    ) {\n        if (null === $normalizer) {\n            $normalizer = $this->createDefaultNormalizer();\n        }\n\n        $parentAtoms = $path->normalize($normalizer)->atoms();\n        $childAtoms = $this->normalize($normalizer)->atoms();\n\n        if ($childAtoms === $parentAtoms) {\n            $diffAtoms = array(static::SELF_ATOM);\n        } else {\n            $diffAtoms = array_diff_assoc($childAtoms, $parentAtoms);\n            $diffAtomIndices = array_keys($diffAtoms);\n            $diffAtoms = array_slice(\n                $childAtoms,\n                array_shift($diffAtomIndices)\n            );\n\n            $fillCount =\n                (count($parentAtoms) - count($childAtoms)) +\n                count($diffAtoms);\n\n            if ($fillCount > 0) {\n                $diffAtoms = array_merge(\n                    array_fill(0, $fillCount, static::PARENT_ATOM),\n                    $diffAtoms\n                );\n            }\n        }\n\n        return $this->createPath($diffAtoms, false);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,333,null,null,null,null,null,null,null,null,null,null,20,4,null,null,16,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,12,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,34,16,16,null,null,34,34,34,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,35,17,17,null,35,null,35,35,35,35,35,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,36,19,19,null,36,36,null,36,4,4,32,32,32,32,32,32,null,null,32,32,null,32,22,22,null,22,22,null,null,36,null,null]},{"name":"Eloquent\/Pathogen\/AbsolutePathInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen;\n\n\/**\n * The interface implemented by absolute paths.\n *\/\ninterface AbsolutePathInterface extends PathInterface\n{\n    \/**\n     * Determine whether this path is the root path.\n     *\n     * The root path is an absolute path with no atoms.\n     *\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return boolean True if this path is the root path.\n     *\/\n    public function isRoot(\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    );\n\n    \/**\n     * Determine if this path is the direct parent of the supplied path.\n     *\n     * @param AbsolutePathInterface                   $path       The child path.\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return boolean True if this path is the direct parent of the supplied\n     *     path.\n     *\/\n    public function isParentOf(\n        AbsolutePathInterface $path,\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    );\n\n    \/**\n     * Determine if this path is an ancestor of the supplied path.\n     *\n     * @param AbsolutePathInterface                   $path       The child path.\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return boolean True if this path is an ancestor of the supplied path.\n     *\/\n    public function isAncestorOf(\n        AbsolutePathInterface $path,\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    );\n\n    \/**\n     * Determine the shortest path from the supplied path to this path.\n     *\n     * For example, given path A equal to '\/foo\/bar', and path B equal to\n     * '\/foo\/baz', A relative to B would be '..\/bar'.\n     *\n     * @param AbsolutePathInterface $path The path that the generated path will\n     *     be relative to.\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return RelativePathInterface A relative path from the supplied path to\n     *     this path.\n     *\/\n    public function relativeTo(\n        AbsolutePathInterface $path,\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    );\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/AbstractPath.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen;\n\n\/**\n * Abstract base class for implementing PathInterface.\n *\/\nabstract class AbstractPath implements PathInterface\n{\n    \/**\n     * Construct a new path instance.\n     *\n     * @param mixed<string> $atoms                The path atoms.\n     * @param boolean|null  $hasTrailingSeparator True if this path has a\n     *     trailing separator.\n     *\n     * @throws Exception\\InvalidPathAtomExceptionInterface If any of the\n     *     supplied path atoms are invalid.\n     *\/\n    public function __construct($atoms, $hasTrailingSeparator = null)\n    {\n        if (null === $hasTrailingSeparator) {\n            $hasTrailingSeparator = false;\n        }\n\n        $this->atoms = $this->normalizeAtoms($atoms);\n        $this->hasTrailingSeparator = $hasTrailingSeparator === true;\n    }\n\n    \/\/ Implementation of PathInterface =========================================\n\n    \/**\n     * Get the atoms of this path.\n     *\n     * For example, the path '\/foo\/bar' has the atoms 'foo' and 'bar'.\n     *\n     * @return array<integer,string> The atoms of this path as an array of\n     * strings.\n     *\/\n    public function atoms()\n    {\n        return $this->atoms;\n    }\n\n    \/**\n     * Get a subset of the atoms of this path.\n     *\n     * @param integer      $index  The index of the first atom.\n     * @param integer|null $length The maximum number of atoms.\n     *\n     * @return array<integer,string> An array of strings representing the subset\n     *     of path atoms.\n     *\/\n    public function sliceAtoms($index, $length = null)\n    {\n        $atoms = $this->atoms();\n        if (null === $length) {\n            $length = count($atoms);\n        }\n\n        return array_slice($atoms, $index, $length);\n    }\n\n    \/**\n     * Determine if this path has any atoms.\n     *\n     * @return boolean True if this path has at least one atom.\n     *\/\n    public function hasAtoms()\n    {\n        return count($this->atoms()) > 0;\n    }\n\n    \/**\n     * Determine if this path has a trailing separator.\n     *\n     * @return boolean True if this path has a trailing separator.\n     *\/\n    public function hasTrailingSeparator()\n    {\n        return $this->hasTrailingSeparator;\n    }\n\n    \/**\n     * Generate a string representation of this path.\n     *\n     * @return string A string representation of this path.\n     *\/\n    public function string()\n    {\n        return\n            implode(static::ATOM_SEPARATOR, $this->atoms()) .\n            ($this->hasTrailingSeparator() ? static::ATOM_SEPARATOR : '')\n        ;\n    }\n\n    \/**\n     * Generate a string representation of this path.\n     *\n     * @return string A string representation of this path.\n     *\/\n    public function __toString()\n    {\n        return $this->string();\n    }\n\n    \/**\n     * Get this path's name.\n     *\n     * @return string The last path atom if one exists, otherwise an empty\n     *     string.\n     *\/\n    public function name()\n    {\n        $atoms = $this->atoms();\n        $numAtoms = count($atoms);\n\n        if ($numAtoms > 0) {\n            return $atoms[$numAtoms - 1];\n        }\n\n        return '';\n    }\n\n    \/**\n     * Get this path's name atoms.\n     *\n     * For example, the path name 'foo.bar' has the atoms 'foo' and 'bar'.\n     *\n     * @return array<integer,string> The atoms of this path's name as an array\n     *     of strings.\n     *\/\n    public function nameAtoms()\n    {\n        return explode(static::EXTENSION_SEPARATOR, $this->name());\n    }\n\n    \/**\n     * Get a subset of this path's name atoms.\n     *\n     * @param integer      $index  The index of the first atom.\n     * @param integer|null $length The maximum number of atoms.\n     *\n     * @return array<integer,string> An array of strings representing the subset\n     *     of path name atoms.\n     *\/\n    public function sliceNameAtoms($index, $length = null)\n    {\n        $atoms = $this->nameAtoms();\n        if (null === $length) {\n            $length = count($atoms);\n        }\n\n        return array_slice($atoms, $index, $length);\n    }\n\n    \/**\n     * Get this path's name, excluding the last extension.\n     *\n     * @return string The last atom of this path, excluding the last extension.\n     *     If this path has no atoms, an empty string is returned.\n     *\/\n    public function nameWithoutExtension()\n    {\n        $atoms = $this->nameAtoms();\n        if (count($atoms) > 1) {\n            array_pop($atoms);\n\n            return implode(static::EXTENSION_SEPARATOR, $atoms);\n        }\n\n        return $atoms[0];\n    }\n\n    \/**\n     * Get this path's name, excluding all extensions.\n     *\n     * @return string The last atom of this path, excluding any extensions. If\n     *     this path has no atoms, an empty string is returned.\n     *\/\n    public function namePrefix()\n    {\n        $atoms = $this->nameAtoms();\n\n        return $atoms[0];\n    }\n\n    \/**\n     * Get all of this path's extensions.\n     *\n     * @return string|null The extensions of this path's last atom. If the last\n     *     atom has no extensions, or this path has no atoms, this method will\n     *     return null.\n     *\/\n    public function nameSuffix()\n    {\n        $atoms = $this->nameAtoms();\n        if (count($atoms) > 1) {\n            array_shift($atoms);\n\n            return implode(static::EXTENSION_SEPARATOR, $atoms);\n        }\n\n        return null;\n    }\n\n    \/**\n     * Get this path's last extension.\n     *\n     * @return string|null The last extension of this path's last atom. If the\n     *     last atom has no extensions, or this path has no atoms, this method\n     *     will return null.\n     *\/\n    public function extension()\n    {\n        $atoms = $this->nameAtoms();\n        $numParts = count($atoms);\n\n        if ($numParts > 1) {\n            return $atoms[$numParts - 1];\n        }\n\n        return null;\n    }\n\n    \/**\n     * Determine if this path has any extensions.\n     *\n     * @return boolean True if this path's last atom has any extensions.\n     *\/\n    public function hasExtension()\n    {\n        return count($this->nameAtoms()) > 1;\n    }\n\n    \/**\n     * Determine if this path contains a substring.\n     *\n     * @param string       $needle        The substring to search for.\n     * @param boolean|null $caseSensitive True if case sensitive.\n     *\n     * @return boolean\n     *\/\n    public function contains($needle, $caseSensitive = null)\n    {\n        if ('' === $needle) {\n            return true;\n        }\n        if (null === $caseSensitive) {\n            $caseSensitive = false;\n        }\n\n        if ($caseSensitive) {\n            return false !== mb_strpos($this->string(), $needle);\n        }\n\n        return false !== mb_stripos($this->string(), $needle);\n    }\n\n    \/**\n     * Determine if this path starts with a substring.\n     *\n     * @param string       $needle        The substring to search for.\n     * @param boolean|null $caseSensitive True if case sensitive.\n     *\n     * @return boolean\n     *\/\n    public function startsWith($needle, $caseSensitive = null)\n    {\n        if ('' === $needle) {\n            return true;\n        }\n        if (null === $caseSensitive) {\n            $caseSensitive = false;\n        }\n\n        if ($caseSensitive) {\n            return 0 === mb_strpos($this->string(), $needle);\n        }\n\n        return 0 === mb_stripos($this->string(), $needle);\n    }\n\n    \/**\n     * Determine if this path ends with a substring.\n     *\n     * @param string       $needle        The substring to search for.\n     * @param boolean|null $caseSensitive True if case sensitive.\n     *\n     * @return boolean\n     *\/\n    public function endsWith($needle, $caseSensitive = null)\n    {\n        if ('' === $needle) {\n            return true;\n        }\n        if (null === $caseSensitive) {\n            $caseSensitive = false;\n        }\n\n        $end = mb_substr($this->string(), -mb_strlen($needle));\n\n        if ($caseSensitive) {\n            return $end === $needle;\n        }\n\n        return mb_strtolower($end) === mb_strtolower($needle);\n    }\n\n    \/**\n     * Determine if this path matches a wildcard pattern.\n     *\n     * @param string       $pattern       The pattern to check against.\n     * @param boolean|null $caseSensitive True if case sensitive.\n     * @param integer|null $flags         Additional flags.\n     *\n     * @return boolean\n     *\/\n    public function matches($pattern, $caseSensitive = null, $flags = null)\n    {\n        if (null === $caseSensitive) {\n            $caseSensitive = false;\n        }\n        if (null === $flags) {\n            $flags = 0;\n        }\n        if (!$caseSensitive) {\n            $flags = $flags | FNM_CASEFOLD;\n        }\n\n        return fnmatch($pattern, $this->string(), $flags);\n    }\n\n    \/**\n     * Determine if this path matches a regular expression.\n     *\n     * @param string       $pattern  The pattern to check against.\n     * @param array|null   &$matches Populated with the pattern matches.\n     * @param integer|null $flags    Additional flags.\n     * @param integer|null $offset   Start searching from this byte offset.\n     *\n     * @return boolean\n     *\/\n    public function matchesRegex(\n        $pattern,\n        array &$matches = null,\n        $flags = null,\n        $offset = null\n    ) {\n        if (null === $flags) {\n            $flags = 0;\n        }\n        if (null === $offset) {\n            $offset = 0;\n        }\n\n        return 1 === preg_match(\n            $pattern,\n            $this->string(),\n            $matches,\n            $flags,\n            $offset\n        );\n    }\n\n    \/**\n     * Determine if this path's name contains a substring.\n     *\n     * @param string       $needle        The substring to search for.\n     * @param boolean|null $caseSensitive True if case sensitive.\n     *\n     * @return boolean\n     *\/\n    public function nameContains($needle, $caseSensitive = null)\n    {\n        if ('' === $needle) {\n            return true;\n        }\n        if (null === $caseSensitive) {\n            $caseSensitive = false;\n        }\n\n        if ($caseSensitive) {\n            return false !== mb_strpos($this->name(), $needle);\n        }\n\n        return false !== mb_stripos($this->name(), $needle);\n    }\n\n    \/**\n     * Determine if this path's name starts with a substring.\n     *\n     * @param string       $needle        The substring to search for.\n     * @param boolean|null $caseSensitive True if case sensitive.\n     *\n     * @return boolean\n     *\/\n    public function nameStartsWith($needle, $caseSensitive = null)\n    {\n        if ('' === $needle) {\n            return true;\n        }\n        if (null === $caseSensitive) {\n            $caseSensitive = false;\n        }\n\n        if ($caseSensitive) {\n            return 0 === mb_strpos($this->name(), $needle);\n        }\n\n        return 0 === mb_stripos($this->name(), $needle);\n    }\n\n    \/**\n     * Determine if this path's name matches a wildcard pattern.\n     *\n     * @param string       $pattern       The pattern to check against.\n     * @param boolean|null $caseSensitive True if case sensitive.\n     * @param integer|null $flags         Additional flags.\n     *\n     * @return boolean\n     *\/\n    public function nameMatches($pattern, $caseSensitive = null, $flags = null)\n    {\n        if (null === $caseSensitive) {\n            $caseSensitive = false;\n        }\n        if (null === $flags) {\n            $flags = 0;\n        }\n        if (!$caseSensitive) {\n            $flags = $flags | FNM_CASEFOLD;\n        }\n\n        return fnmatch($pattern, $this->name(), $flags);\n    }\n\n    \/**\n     * Determine if this path's name matches a regular expression.\n     *\n     * @param string       $pattern  The pattern to check against.\n     * @param array|null   &$matches Populated with the pattern matches.\n     * @param integer|null $flags    Additional flags.\n     * @param integer|null $offset   Start searching from this byte offset.\n     *\n     * @return boolean\n     *\/\n    public function nameMatchesRegex(\n        $pattern,\n        array &$matches = null,\n        $flags = null,\n        $offset = null\n    ) {\n        if (null === $flags) {\n            $flags = 0;\n        }\n        if (null === $offset) {\n            $offset = 0;\n        }\n\n        return 1 === preg_match(\n            $pattern,\n            $this->name(),\n            $matches,\n            $flags,\n            $offset\n        );\n    }\n\n    \/**\n     * Get the parent of this path a specified number of levels up.\n     *\n     * @param integer|null $numLevels The number of\n     *     levels up. Defaults to 1.\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the parent.\n     *\n     * @return PathInterface The parent of this path $numLevels up.\n     *\/\n    public function parent(\n        $numLevels = null,\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    ) {\n        if (null === $numLevels) {\n            $numLevels = 1;\n        }\n\n        $atoms = array_merge(\n            $this->atoms(),\n            array_fill(0, $numLevels, static::PARENT_ATOM)\n        );\n\n        $parent = $this->createPath(\n            $atoms,\n            $this instanceof AbsolutePathInterface\n        );\n\n        if (null !== $normalizer) {\n            $parent = $parent->normalize($normalizer);\n        }\n\n        return $parent;\n    }\n\n    \/**\n     * Strips the trailing slash from this path.\n     *\n     * @return PathInterface A new path instance with the trailing slash removed\n     *     from this path. If this path has no trailing slash, the path is\n     *     returned unmodified.\n     *\/\n    public function stripTrailingSlash()\n    {\n        if (!$this->hasTrailingSeparator()) {\n            return $this;\n        }\n\n        return $this->createPath(\n            $this->atoms(),\n            $this instanceof AbsolutePathInterface\n        );\n    }\n\n    \/**\n     * Strips the last extension from this path.\n     *\n     * @return PathInterface A new path instance with the last extension removed\n     *     from this path. If this path has no extensions, the path is returned\n     *     unmodified.\n     *\/\n    public function stripExtension()\n    {\n        return $this->replaceExtension(null);\n    }\n\n    \/**\n     * Strips all extensions from this path.\n     *\n     * @return PathInterface A new path instance with all extensions removed\n     *     from this path. If this path has no extensions, the path is returned\n     *     unmodified.\n     *\/\n    public function stripNameSuffix()\n    {\n        return $this->replaceNameSuffix(null);\n    }\n\n    \/**\n     * Joins one or more atoms to this path.\n     *\n     * @param string     $atom            A path atom to append.\n     * @param string,... $additionalAtoms Additional path atoms to append.\n     *\n     * @return PathInterface A new path with the supplied atom(s) suffixed to\n     *     this path.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If any joined atoms\n     *     are invalid.\n     *\/\n    public function joinAtoms($atom)\n    {\n        return $this->joinAtomSequence(func_get_args());\n    }\n\n    \/**\n     * Joins a sequence of atoms to this path.\n     *\n     * @param mixed<string> $atoms The path atoms to append.\n     *\n     * @return PathInterface A new path with the supplied sequence of atoms\n     *     suffixed to this path.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If any joined atoms\n     *     are invalid.\n     *\/\n    public function joinAtomSequence($atoms)\n    {\n        if (!is_array($atoms)) {\n            $atoms = iterator_to_array($atoms);\n        }\n\n        return $this->createPath(\n            array_merge($this->atoms(), $atoms),\n            $this instanceof AbsolutePathInterface\n        );\n    }\n\n    \/**\n     * Joins the supplied path to this path.\n     *\n     * @param RelativePathInterface $path The path whose atoms should be joined\n     *     to this path.\n     *\n     * @return PathInterface A new path with the supplied path suffixed to this\n     *     path.\n     *\/\n    public function join(RelativePathInterface $path)\n    {\n        return $this->joinAtomSequence($path->atoms());\n    }\n\n    \/**\n     * Returns a new path instance with a trailing slash suffixed to this path.\n     *\n     * @return PathInterface\n     *\/\n    public function joinTrailingSlash()\n    {\n        if ($this->hasTrailingSeparator()) {\n            return $this;\n        }\n\n        return $this->createPath(\n            $this->atoms(),\n            $this instanceof AbsolutePathInterface,\n            true\n        );\n    }\n\n    \/**\n     * Joins one or more extensions to this path.\n     *\n     * @param string     $extension            An extension to append.\n     * @param string,... $additionalExtensions Additional extensions to append.\n     *\n     * @return PathInterface A new path instance with the supplied extensions\n     *     suffixed to this path.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If the suffixed\n     *     extensions cause the atom to be invalid.\n     *\/\n    public function joinExtensions($extension)\n    {\n        return $this->joinExtensionSequence(func_get_args());\n    }\n\n    \/**\n     * Joins a sequence of extensions to this path.\n     *\n     * @param mixed<string> $extensions\n     *\n     * @return PathInterface A new path instance with the supplied extensions\n     *     suffixed to this path.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If the suffixed\n     *     extensions cause the atom to be invalid.\n     *\/\n    public function joinExtensionSequence($extensions)\n    {\n        if (!is_array($extensions)) {\n            $extensions = iterator_to_array($extensions);\n        }\n\n        $atoms = $this->nameAtoms();\n        if (array('', '') === $atoms) {\n            array_pop($atoms);\n        }\n\n        return $this->replaceName(\n            implode(\n                static::EXTENSION_SEPARATOR,\n                array_merge($atoms, $extensions)\n            )\n        );\n    }\n\n    \/**\n     * Suffixes this path's name with a supplied string.\n     *\n     * @param string $suffix The string to suffix to the path name.\n     *\n     * @return PathInterface A new path instance with the supplied string\n     *     suffixed to the last path atom.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If the suffix causes\n     *     the atom to be invalid.\n     *\/\n    public function suffixName($suffix)\n    {\n        $name = $this->name();\n        if (static::SELF_ATOM === $name) {\n            return $this->replaceName($suffix);\n        }\n\n        return $this->replaceName($name . $suffix);\n    }\n\n    \/**\n     * Prefixes this path's name with a supplied string.\n     *\n     * @param string $prefix The string to prefix to the path name.\n     *\n     * @return PathInterface A new path instance with the supplied string\n     *     prefixed to the last path atom.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If the prefix causes\n     *     the atom to be invalid.\n     *\/\n    public function prefixName($prefix)\n    {\n        $name = $this->name();\n        if (static::SELF_ATOM === $name) {\n            return $this->replaceName($prefix);\n        }\n\n        return $this->replaceName($prefix . $name);\n    }\n\n    \/**\n     * Replace a section of this path with the supplied atom sequence.\n     *\n     * @param integer       $index       The start index of the replacement.\n     * @param mixed<string> $replacement The replacement atom sequence.\n     * @param integer|null  $length      The number of atoms to replace. If\n     *     $length is null, the entire remainder of the path will be replaced.\n     *\n     * @return PathInterface A new path instance that has a portion of this\n     *     path's atoms replaced with a different sequence of atoms.\n     *\/\n    public function replace($index, $replacement, $length = null)\n    {\n        $atoms = $this->atoms();\n\n        if (!is_array($replacement)) {\n            $replacement = iterator_to_array($replacement);\n        }\n        if (null === $length) {\n            $length = count($atoms);\n        }\n\n        array_splice($atoms, $index, $length, $replacement);\n\n        return $this->createPath(\n            $atoms,\n            $this instanceof AbsolutePathInterface\n        );\n    }\n\n    \/**\n     * Replace this path's name.\n     *\n     * @param string $name The new path name.\n     *\n     * @return PathInterface A new path instance with the supplied name\n     *     replacing the existing one.\n     *\/\n    public function replaceName($name)\n    {\n        $atoms = $this->atoms();\n        $numAtoms = count($atoms);\n\n        if ($numAtoms > 0) {\n            if ('' === $name) {\n                array_pop($atoms);\n            } else {\n                $atoms[$numAtoms - 1] = $name;\n            }\n        } elseif ('' !== $name) {\n            $atoms[] = $name;\n        }\n\n        return $this->createPath(\n            $atoms,\n            $this instanceof AbsolutePathInterface\n        );\n    }\n\n    \/**\n     * Replace this path's name, but keep the last extension.\n     *\n     * @param string $nameWithoutExtension The replacement string.\n     *\n     * @return PathInterface A new path instance with the supplied name\n     *     replacing the portion of the existing name preceding the last\n     *     extension.\n     *\/\n    public function replaceNameWithoutExtension($nameWithoutExtension)\n    {\n        $atoms = $this->nameAtoms();\n        if (count($atoms) < 2) {\n            return $this->replaceName($nameWithoutExtension);\n        }\n\n        array_splice($atoms, 0, -1, array($nameWithoutExtension));\n\n        return $this->replaceName(implode(self::EXTENSION_SEPARATOR, $atoms));\n    }\n\n    \/**\n     * Replace this path's name, but keep any extensions.\n     *\n     * @param string $namePrefix The replacement string.\n     *\n     * @return PathInterface A new path instance with the supplied name prefix\n     *     replacing the existing one.\n     *\/\n    public function replaceNamePrefix($namePrefix)\n    {\n        return $this->replaceNameAtoms(0, array($namePrefix), 1);\n    }\n\n    \/**\n     * Replace all of this path's extensions.\n     *\n     * @param string|null $nameSuffix The replacement string, or null to remove\n     *     all extensions.\n     *\n     * @return PathInterface A new path instance with the supplied name suffix\n     *     replacing the existing one.\n     *\/\n    public function replaceNameSuffix($nameSuffix)\n    {\n        $atoms = $this->nameAtoms();\n        if (array('', '') === $atoms) {\n            if (null === $nameSuffix) {\n                return $this;\n            }\n\n            return $this->replaceName(\n                static::EXTENSION_SEPARATOR . $nameSuffix\n            );\n        }\n\n        $numAtoms = count($atoms);\n\n        if (null === $nameSuffix) {\n            $replacement = array();\n        } else {\n            $replacement = array($nameSuffix);\n        }\n        array_splice($atoms, 1, count($atoms), $replacement);\n\n        return $this->replaceName(implode(self::EXTENSION_SEPARATOR, $atoms));\n    }\n\n    \/**\n     * Replace this path's last extension.\n     *\n     * @param string|null $extension The replacement string, or null to remove\n     *     the last extension.\n     *\n     * @return PathInterface A new path instance with the supplied extension\n     *     replacing the existing one.\n     *\/\n    public function replaceExtension($extension)\n    {\n        $atoms = $this->nameAtoms();\n        if (array('', '') === $atoms) {\n            if (null === $extension) {\n                return $this;\n            }\n\n            return $this->replaceName(\n                static::EXTENSION_SEPARATOR . $extension\n            );\n        }\n\n        $numAtoms = count($atoms);\n\n        if ($numAtoms > 1) {\n            if (null === $extension) {\n                $replacement = array();\n            } else {\n                $replacement = array($extension);\n            }\n\n            array_splice($atoms, -1, $numAtoms, $replacement);\n        } elseif (null !== $extension) {\n            $atoms[] = $extension;\n        }\n\n        return $this->replaceName(implode(self::EXTENSION_SEPARATOR, $atoms));\n    }\n\n    \/**\n     * Replace a section of this path's name with the supplied name atom\n     * sequence.\n     *\n     * @param integer       $index       The start index of the replacement.\n     * @param mixed<string> $replacement The replacement name atom sequence.\n     * @param integer|null  $length      The number of atoms to replace. If\n     *     $length is null, the entire remainder of the path name will be\n     *     replaced.\n     *\n     * @return PathInterface A new path instance that has a portion of this\n     *     name's atoms replaced with a different sequence of atoms.\n     *\/\n    public function replaceNameAtoms($index, $replacement, $length = null)\n    {\n        $atoms = $this->nameAtoms();\n\n        if (!is_array($replacement)) {\n            $replacement = iterator_to_array($replacement);\n        }\n        if (null === $length) {\n            $length = count($atoms);\n        }\n\n        array_splice($atoms, $index, $length, $replacement);\n\n        return $this->replaceName(implode(self::EXTENSION_SEPARATOR, $atoms));\n    }\n\n    \/**\n     * Normalize this path to its most canonical form.\n     *\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer\n     *\n     * @return PathInterface The normalized path.\n     *\/\n    public function normalize(\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    ) {\n        if (null === $normalizer) {\n            $normalizer = $this->createDefaultNormalizer();\n        }\n\n        return $normalizer->normalize($this);\n    }\n\n    \/\/ Implementation details ==================================================\n\n    \/**\n     * @param mixed<string> $atoms\n     *\n     * @return array<string>\n     *\/\n    protected function normalizeAtoms($atoms)\n    {\n        $normalizedAtoms = array();\n        foreach ($atoms as $atom) {\n            $this->validateAtom($atom);\n            $normalizedAtoms[] = $atom;\n        }\n\n        return $normalizedAtoms;\n    }\n\n    \/**\n     * @param string $atom\n     *\/\n    protected function validateAtom($atom)\n    {\n        if ('' === $atom) {\n            throw new Exception\\EmptyPathAtomException;\n        } elseif (false !== strpos($atom, static::ATOM_SEPARATOR)) {\n            throw new Exception\\PathAtomContainsSeparatorException($atom);\n        }\n    }\n\n    \/**\n     * @param mixed<string> $atoms\n     * @param boolean       $isAbsolute\n     * @param boolean|null  $hasTrailingSeparator\n     *\n     * @return PathInterface\n     *\/\n    protected function createPath(\n        $atoms,\n        $isAbsolute,\n        $hasTrailingSeparator = null\n    ) {\n        if ($isAbsolute) {\n            return new AbsolutePath($atoms, $hasTrailingSeparator);\n        }\n\n        return new RelativePath($atoms, $hasTrailingSeparator);\n    }\n\n    \/**\n     * @return Normalizer\\PathNormalizerInterface\n     *\/\n    protected function createDefaultNormalizer()\n    {\n        return new Normalizer\\PathNormalizer;\n    }\n\n    private $atoms;\n    private $hasTrailingSeparator;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2059,1122,1122,null,2059,1964,1964,null,null,null,null,null,null,null,null,null,null,null,null,null,1869,null,null,null,null,null,null,null,null,null,null,null,null,null,14,14,7,7,null,14,null,null,null,null,null,null,null,null,null,66,null,null,null,null,null,null,null,null,null,1196,null,null,null,null,null,null,null,null,null,null,858,858,858,null,null,null,null,null,null,null,null,null,14,null,null,null,null,null,null,null,null,null,null,856,856,null,856,812,null,null,44,null,null,null,null,null,null,null,null,null,null,null,null,494,null,null,null,null,null,null,null,null,null,null,null,null,null,14,14,7,7,null,14,null,null,null,null,null,null,null,null,null,null,56,56,45,null,45,null,null,11,null,null,null,null,null,null,null,null,null,null,56,null,56,null,null,null,null,null,null,null,null,null,null,null,56,56,45,null,45,null,null,11,null,null,null,null,null,null,null,null,null,null,null,56,56,null,56,45,null,null,11,null,null,null,null,null,null,null,null,null,56,null,null,null,null,null,null,null,null,null,null,null,null,70,14,null,56,28,28,null,56,28,null,null,28,null,null,null,null,null,null,null,null,null,null,null,null,70,14,null,56,28,28,null,56,28,null,null,28,null,null,null,null,null,null,null,null,null,null,null,null,70,14,null,56,28,28,null,56,null,56,28,null,null,28,null,null,null,null,null,null,null,null,null,null,null,null,null,140,112,112,140,126,126,140,126,126,null,140,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,35,28,28,35,21,21,null,35,35,35,35,35,null,35,null,null,null,null,null,null,null,null,null,null,null,null,66,12,null,54,30,30,null,54,24,null,null,30,null,null,null,null,null,null,null,null,null,null,null,null,60,12,null,48,24,24,null,48,24,null,null,24,null,null,null,null,null,null,null,null,null,null,null,null,null,120,96,96,120,108,108,120,108,108,null,120,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,30,24,24,30,18,18,null,30,30,30,30,30,null,30,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,69,55,55,null,69,69,69,69,null,69,69,null,69,null,69,50,50,null,69,null,null,null,null,null,null,null,null,null,null,null,35,14,null,null,21,21,null,21,null,null,null,null,null,null,null,null,null,null,null,42,null,null,null,null,null,null,null,null,null,null,null,42,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,127,null,null,null,null,null,null,null,null,null,null,null,null,null,null,299,5,5,null,299,299,null,299,null,null,null,null,null,null,null,null,null,null,null,null,null,40,null,null,null,null,null,null,null,null,null,31,7,null,null,24,24,24,null,24,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,56,null,null,null,null,null,null,null,null,null,null,null,null,null,null,116,5,5,null,116,116,6,6,null,116,116,116,116,116,116,null,null,null,null,null,null,null,null,null,null,null,null,null,null,55,55,3,null,null,52,null,null,null,null,null,null,null,null,null,null,null,null,null,null,55,55,6,null,null,49,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,49,null,49,6,6,49,21,21,null,49,null,49,49,null,49,null,null,null,null,null,null,null,null,null,null,null,null,547,547,null,547,507,42,42,465,null,547,36,36,null,547,547,null,547,null,null,null,null,null,null,null,null,null,null,null,null,null,48,48,25,null,null,23,null,23,null,null,null,null,null,null,null,null,null,null,null,null,48,null,null,null,null,null,null,null,null,null,null,null,null,null,90,90,6,3,null,null,3,3,3,null,null,84,null,84,39,39,45,null,84,null,84,null,null,null,null,null,null,null,null,null,null,null,null,null,91,91,6,3,null,null,3,3,3,null,null,85,null,85,49,28,28,21,null,null,49,85,25,25,null,85,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,89,null,89,6,6,89,14,14,null,89,null,89,null,null,null,null,null,null,null,null,null,null,null,null,134,19,19,null,134,null,null,null,null,null,null,null,null,null,null,null,2059,2059,1988,1896,1967,null,1967,null,null,null,null,null,null,null,1988,18,1982,78,null,1976,null,null,null,null,null,null,null,null,null,null,null,null,null,260,135,null,null,125,null,null,null,null,null,null,null,28,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Exception\/AbstractInvalidPathAtomException.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Exception;\n\nuse Exception;\n\n\/**\n * Abstract base class for exceptions implementing\n * InvalidPathAtomExceptionInterface.\n *\/\nabstract class AbstractInvalidPathAtomException extends Exception\n    implements InvalidPathAtomExceptionInterface\n{\n    \/**\n     * Construct a new invalid path atom exception.\n     *\n     * @param string         $atom     The invalid path atom.\n     * @param Exception|null $previous The previous exception, if available.\n     *\/\n    public function __construct($atom, Exception $previous = null)\n    {\n        $this->atom = $atom;\n\n        parent::__construct(\n            sprintf(\n                \"Invalid path atom %s. %s\",\n                var_export($atom, true),\n                $this->reason()\n            ),\n            0,\n            $previous\n        );\n    }\n\n    \/**\n     * Get the invalid path atom.\n     *\n     * @return string The invalid path atom.\n     *\/\n    public function atom()\n    {\n        return $this->atom;\n    }\n\n    \/**\n     * Get the reason message.\n     *\n     * @return string The reason message.\n     *\/\n    abstract public function reason();\n\n    private $atom;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,3,3,3,3,3,3,null,3,3,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Exception\/EmptyPathAtomException.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Exception;\n\nuse Exception;\n\n\/**\n * An empty path atom was supplied.\n *\/\nfinal class EmptyPathAtomException extends AbstractInvalidPathAtomException\n{\n    \/**\n     * Construct a new empty path atom exception.\n     *\n     * @param Exception|null $previous The previous exception, if available.\n     *\/\n    public function __construct(Exception $previous = null)\n    {\n        parent::__construct('', $previous);\n    }\n\n    \/**\n     * Get the reason message.\n     *\n     * @return string The reason message.\n     *\/\n    public function reason()\n    {\n        return 'Path atoms must not be empty strings.';\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,null,null,null,null,1,null,null]},{"name":"Eloquent\/Pathogen\/Exception\/EmptyPathException.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Exception;\n\nuse Exception;\nuse LogicException;\n\n\/**\n * No path atoms were supplied when constructing a new relative path.\n *\/\nfinal class EmptyPathException extends LogicException\n{\n    \/**\n     * Construct a new empty path exception.\n     *\n     * @param Exception|null $previous The previous exception, if available.\n     *\/\n    public function __construct(Exception $previous = null)\n    {\n        parent::__construct(\n            'Relative paths must have at least one atom.',\n            0,\n            $previous\n        );\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,1,null,1,1,null]},{"name":"Eloquent\/Pathogen\/Exception\/InvalidPathAtomCharacterException.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Exception;\n\nuse Exception;\n\n\/**\n * An invalid character was encountered in a path atom.\n *\/\nfinal class InvalidPathAtomCharacterException extends AbstractInvalidPathAtomException\n{\n    \/**\n     * Construct a new invalid path atom character exception.\n     *\n     * @param string         $atom      The invalid path atom.\n     * @param string         $character The invalid character.\n     * @param Exception|null $previous  The previous exception, if available.\n     *\/\n    public function __construct($atom, $character, Exception $previous = null)\n    {\n        $this->character = $character;\n\n        parent::__construct($atom, $previous);\n    }\n\n    \/**\n     * Get the invalid character that caused the exception.\n     *\n     * @return string The invalid character.\n     *\/\n    public function character()\n    {\n        return $this->character;\n    }\n\n    \/**\n     * Get the reason message.\n     *\n     * @return string The reason message.\n     *\/\n    public function reason()\n    {\n        return sprintf(\n            'Path atom contains invalid character %s.',\n            var_export($this->character(), true)\n        );\n    }\n\n    private $character;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,1,1,1,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Exception\/InvalidPathAtomExceptionInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Exception;\n\n\/**\n * Interface for exceptions that handle invalid path atom cases.\n *\/\ninterface InvalidPathAtomExceptionInterface\n{\n    \/**\n     * Get the invalid path atom.\n     *\n     * @return string The invalid path atom.\n     *\/\n    public function atom();\n\n    \/**\n     * Get the reason message.\n     *\n     * @return string The reason message.\n     *\/\n    public function reason();\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Exception\/InvalidPathStateException.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Exception;\n\nuse Exception;\nuse LogicException;\n\n\/**\n * An attempt was made to construct a new path in an invalid state.\n *\/\nfinal class InvalidPathStateException extends LogicException\n{\n    \/**\n     * Construct a new invalid path state exception.\n     *\n     * @param string         $reason   The reason message.\n     * @param Exception|null $previous The previous exception, if available.\n     *\/\n    public function __construct($reason, Exception $previous = null)\n    {\n        $this->reason = $reason;\n\n        parent::__construct(\n            sprintf('Invalid path state. %s', $reason),\n            0,\n            $previous\n        );\n    }\n\n    \/**\n     * Get the reason message.\n     *\n     * @return string The reason message.\n     *\/\n    public function reason()\n    {\n        return $this->reason;\n    }\n\n    private $reason;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,1,1,null,null,null,null,null,null,null,null,1,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Exception\/PathAtomContainsSeparatorException.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Exception;\n\n\/**\n * A supplied path atom contains a path separator.\n *\/\nfinal class PathAtomContainsSeparatorException\n    extends AbstractInvalidPathAtomException\n{\n    \/**\n     * Get the reason message.\n     *\n     * @return string The reason message.\n     *\/\n    public function reason()\n    {\n        return 'Path atoms must not contain separators.';\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null]},{"name":"Eloquent\/Pathogen\/Factory\/Consumer\/PathFactoryTrait.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Factory\\Consumer;\n\nuse Eloquent\\Pathogen\\Factory\\PathFactory;\nuse Eloquent\\Pathogen\\Factory\\PathFactoryInterface;\n\n\/**\n * A trait for classes that take a path factory as a dependency.\n *\/\ntrait PathFactoryTrait\n{\n    \/**\n     * Set the path factory.\n     *\n     * @param PathFactoryInterface $pathFactory\n     *\/\n    public function setPathFactory(PathFactoryInterface $pathFactory)\n    {\n        $this->pathFactory = $pathFactory;\n    }\n\n    \/**\n     * Get the path factory.\n     *\n     * @return PathFactoryInterface\n     *\/\n    public function pathFactory()\n    {\n        if (null === $this->pathFactory) {\n            $this->pathFactory = $this->createDefaultPathFactory();\n        }\n\n        return $this->pathFactory;\n    }\n\n    \/**\n     * @return PathFactoryInterface\n     *\/\n    protected function createDefaultPathFactory()\n    {\n        return new PathFactory;\n    }\n\n    private $pathFactory;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,3,null,null,null,null,null,null,null,null,7,4,4,null,7,null,null,null,null,null,null,null,1,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Factory\/PathFactory.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Factory;\n\nuse Eloquent\\Pathogen\\AbsolutePath;\nuse Eloquent\\Pathogen\\Exception\\InvalidPathAtomExceptionInterface;\nuse Eloquent\\Pathogen\\PathInterface;\nuse Eloquent\\Pathogen\\RelativePath;\n\n\/**\n * A path factory that creates generic, Unix-style path instances.\n *\/\nclass PathFactory implements PathFactoryInterface\n{\n    \/**\n     * Creates a new path instance from its string representation.\n     *\n     * @param string $path The string representation of the path.\n     *\n     * @return PathInterface The newly created path instance.\n     *\/\n    public function create($path)\n    {\n        if ('' === $path) {\n            $path = PathInterface::SELF_ATOM;\n        }\n\n        $isAbsolute = false;\n        $hasTrailingSeparator = false;\n\n        $atoms = explode(PathInterface::ATOM_SEPARATOR, $path);\n        $numAtoms = count($atoms);\n\n        if ($numAtoms > 1) {\n            if ('' === $atoms[0]) {\n                $isAbsolute = true;\n                array_shift($atoms);\n                --$numAtoms;\n            }\n\n            if ('' === $atoms[$numAtoms - 1]) {\n                $hasTrailingSeparator = !$isAbsolute || $numAtoms > 1;\n                array_pop($atoms);\n                --$numAtoms;\n            }\n        }\n\n        foreach ($atoms as $index => $atom) {\n            if ('' === $atom) {\n                array_splice($atoms, $index, 1);\n                --$numAtoms;\n            }\n        }\n\n        return $this->createFromAtoms(\n            $atoms,\n            $isAbsolute,\n            $hasTrailingSeparator\n        );\n    }\n\n    \/**\n     * Creates a new path instance from a set of path atoms.\n     *\n     * Unless otherwise specified, created paths will be absolute, and have no\n     * trailing separator.\n     *\n     * @param mixed<string> $atoms                The path atoms.\n     * @param boolean|null  $isAbsolute           True if the path is absolute.\n     * @param boolean|null  $hasTrailingSeparator True if the path has a\n     *     trailing separator.\n     *\n     * @return PathInterface                     The newly created path instance.\n     * @throws InvalidPathAtomExceptionInterface If any of the supplied atoms\n     *     are invalid.\n     *\/\n    public function createFromAtoms(\n        $atoms,\n        $isAbsolute = null,\n        $hasTrailingSeparator = null\n    ) {\n        if ($isAbsolute) {\n            return new AbsolutePath($atoms, $hasTrailingSeparator);\n        }\n\n        return new RelativePath($atoms, $hasTrailingSeparator);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,20,1,1,null,20,20,null,20,20,null,20,18,13,13,13,13,null,18,5,5,5,5,18,null,20,19,5,5,5,20,null,20,20,20,null,20,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,33,19,null,null,15,null,null]},{"name":"Eloquent\/Pathogen\/Factory\/PathFactoryInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Factory;\n\nuse Eloquent\\Pathogen\\Exception\\InvalidPathAtomExceptionInterface;\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * The interface implemented by path factories.\n *\/\ninterface PathFactoryInterface\n{\n    \/**\n     * Creates a new path instance from its string representation.\n     *\n     * @param string $path The string representation of the path.\n     *\n     * @return PathInterface The newly created path instance.\n     *\/\n    public function create($path);\n\n    \/**\n     * Creates a new path instance from a set of path atoms.\n     *\n     * Unless otherwise specified, created paths will be absolute, and have no\n     * trailing separator.\n     *\n     * @param mixed<string> $atoms                The path atoms.\n     * @param boolean|null  $isAbsolute           True if the path is absolute.\n     * @param boolean|null  $hasTrailingSeparator True if the path has a\n     *     trailing separator.\n     *\n     * @return PathInterface                     The newly created path instance.\n     * @throws InvalidPathAtomExceptionInterface If any of the supplied atoms\n     *     are invalid.\n     *\/\n    public function createFromAtoms(\n        $atoms,\n        $isAbsolute = null,\n        $hasTrailingSeparator = null\n    );\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/FileSystem\/AbsoluteFileSystemPathInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\FileSystem;\n\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\n\n\/**\n * The interface implemented by absolute file system paths.\n *\/\ninterface AbsoluteFileSystemPathInterface extends\n    AbsolutePathInterface,\n    FileSystemPathInterface\n{\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/FileSystem\/AbstractAbsoluteFileSystemPath.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\FileSystem;\n\nuse Eloquent\\Pathogen\\AbsolutePath;\nuse Eloquent\\Pathogen\\Normalizer\\PathNormalizerInterface;\n\n\/**\n * Represents an absolute file system path.\n *\/\nabstract class AbstractAbsoluteFileSystemPath extends AbsolutePath implements\n    AbsoluteFileSystemPathInterface\n{\n    \/\/ Implementation of PathInterface =========================================\n\n    \/**\n     * Get the parent of this path a specified number of levels up.\n     *\n     * @param integer|null $numLevels The number of levels up.\n     *     Defaults to 1.\n     * @param PathNormalizerInterface|null $normalizer The normalizer to use\n     *     when determining the parent.\n     *\n     * @return PathInterface The parent of this path $numLevels up.\n     *\/\n    public function parent(\n        $numLevels = null,\n        PathNormalizerInterface $normalizer = null\n    ) {\n        if (null === $normalizer) {\n            $normalizer = $this->createDefaultNormalizer();\n        }\n\n        return parent::parent($numLevels, $normalizer);\n    }\n\n    \/\/ Implementation details ==================================================\n\n    \/**\n     * @return PathNormalizerInterface\n     *\/\n    protected function createDefaultNormalizer()\n    {\n        return new Normalizer\\FileSystemPathNormalizer;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,40,40,40,null,40,null,null,null,null,null,null,null,null,null,83,null,null]},{"name":"Eloquent\/Pathogen\/FileSystem\/AbstractRelativeFileSystemPath.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\FileSystem;\n\nuse Eloquent\\Pathogen\\RelativePath;\nuse Eloquent\\Pathogen\\Normalizer\\PathNormalizerInterface;\n\n\/**\n * Represents a relative file system path.\n *\/\nabstract class AbstractRelativeFileSystemPath extends RelativePath implements\n    RelativeFileSystemPathInterface\n{\n    \/\/ Implementation of PathInterface =========================================\n\n    \/**\n     * Get the parent of this path a specified number of levels up.\n     *\n     * @param integer|null $numLevels The number of levels up.\n     *     Defaults to 1.\n     * @param PathNormalizerInterface|null $normalizer The normalizer to use\n     *     when determining the parent.\n     *\n     * @return PathInterface The parent of this path $numLevels up.\n     *\/\n    public function parent(\n        $numLevels = null,\n        PathNormalizerInterface $normalizer = null\n    ) {\n        if (null === $normalizer) {\n            $normalizer = $this->createDefaultNormalizer();\n        }\n\n        return parent::parent($numLevels, $normalizer);\n    }\n\n    \/\/ Implementation details ==================================================\n\n    \/**\n     * @return PathNormalizerInterface\n     *\/\n    protected function createDefaultNormalizer()\n    {\n        return new Normalizer\\FileSystemPathNormalizer;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,10,10,10,null,10,null,null,null,null,null,null,null,null,null,20,null,null]},{"name":"Eloquent\/Pathogen\/FileSystem\/Factory\/AbstractFileSystemPathFactory.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\FileSystem\\Factory;\n\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\nuse Eloquent\\Pathogen\\Factory\\PathFactoryInterface;\nuse Eloquent\\Pathogen\\Unix\\Factory\\UnixPathFactory;\nuse Eloquent\\Pathogen\\Windows\\Factory\\WindowsPathFactory;\nuse Icecave\\Isolator\\Isolator;\n\n\/**\n * Abstract base class for classes implementing FileSystemPathFactoryInterface.\n *\/\nabstract class AbstractFileSystemPathFactory implements\n    FileSystemPathFactoryInterface\n{\n    \/**\n     * Construct a new file system path factory.\n     *\n     * @param PathFactoryInterface|null $unixFactory The path factory to use\n     *     for Unix paths.\n     * @param PathFactoryInterface|null $windowsFactory The path factory to use\n     *     for Windows paths.\n     * @param Isolator|null $isolator The isolator to use.\n     *\/\n    public function __construct(\n        PathFactoryInterface $unixFactory = null,\n        PathFactoryInterface $windowsFactory = null,\n        Isolator $isolator = null\n    ) {\n        if (null === $unixFactory) {\n            $unixFactory = new UnixPathFactory;\n        }\n        if (null === $windowsFactory) {\n            $windowsFactory = new WindowsPathFactory;\n        }\n\n        $this->unixFactory = $unixFactory;\n        $this->windowsFactory = $windowsFactory;\n        $this->isolator = Isolator::get($isolator);\n    }\n\n    \/**\n     * Get the path factory used for Unix paths.\n     *\n     * @return PathFactoryInterface The path factory used for Unix paths.\n     *\/\n    public function unixFactory()\n    {\n        return $this->unixFactory;\n    }\n\n    \/**\n     * Get the path factory used for Windows paths.\n     *\n     * @return PathFactoryInterface The path factory used for Windows paths.\n     *\/\n    public function windowsFactory()\n    {\n        return $this->windowsFactory;\n    }\n\n    \/**\n     * Create a path representing the current working directory.\n     *\n     * @return AbsolutePathInterface A new path instance representing the\n     *     current working directory path.\n     *\/\n    public function createWorkingDirectoryPath()\n    {\n        return $this->factoryByPlatform()\n            ->create($this->isolator()->getcwd());\n    }\n\n    \/**\n     * Create a path representing the system temporary directory.\n     *\n     * @return AbsolutePathInterface A new path instance representing the system\n     *     default temporary directory path.\n     *\/\n    public function createTemporaryDirectoryPath()\n    {\n        return $this->factoryByPlatform()\n            ->create($this->isolator()->sys_get_temp_dir());\n    }\n\n    \/**\n     * Create a path representing a suitable for use as the location for a new\n     * temporary file or directory.\n     *\n     * This path is not guaranteed to be unused, but collisions are fairly\n     * unlikely.\n     *\n     * @param string|null $prefix A string to use as a prefix for the path name.\n     *\n     * @return AbsolutePathInterface A new path instance representing the new\n     *     temporary path.\n     *\/\n    public function createTemporaryPath($prefix = null)\n    {\n        if (null === $prefix) {\n            $prefix = '';\n        }\n\n        return $this->createTemporaryDirectoryPath()\n            ->joinAtoms($this->isolator()->uniqid($prefix, true));\n    }\n\n    \/**\n     * @return Isolator\n     *\/\n    protected function isolator()\n    {\n        return $this->isolator;\n    }\n\n    \/**\n     * @return PathFactoryInterface\n     *\/\n    protected function factoryByPlatform()\n    {\n        if ($this->isolator()->defined('PHP_WINDOWS_VERSION_BUILD')) {\n            return $this->windowsFactory();\n        }\n\n        return $this->unixFactory();\n    }\n\n    private $unixFactory;\n    private $windowsFactory;\n    private $isolator;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,29,6,6,29,6,6,null,29,29,29,29,null,null,null,null,null,null,null,null,17,null,null,null,null,null,null,null,null,null,13,null,null,null,null,null,null,null,null,null,null,5,5,null,null,null,null,null,null,null,null,null,null,10,10,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,6,4,4,null,6,6,null,null,null,null,null,null,null,19,null,null,null,null,null,null,null,19,8,null,null,11,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/FileSystem\/Factory\/Consumer\/FileSystemPathFactoryTrait.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\FileSystem\\Factory\\Consumer;\n\nuse Eloquent\\Pathogen\\Factory\\Consumer\\PathFactoryTrait;\nuse Eloquent\\Pathogen\\FileSystem\\Factory\\FileSystemPathFactory;\n\n\/**\n * A trait for classes that take a file system path factory as a dependency.\n *\/\ntrait FileSystemPathFactoryTrait\n{\n    use PathFactoryTrait;\n\n    \/**\n     * @return PathFactoryInterface\n     *\/\n    protected function createDefaultPathFactory()\n    {\n        return new FileSystemPathFactory;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null]},{"name":"Eloquent\/Pathogen\/FileSystem\/Factory\/Consumer\/PlatformFileSystemPathFactoryTrait.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\FileSystem\\Factory\\Consumer;\n\nuse Eloquent\\Pathogen\\Factory\\Consumer\\PathFactoryTrait;\nuse Eloquent\\Pathogen\\FileSystem\\Factory\\PlatformFileSystemPathFactory;\n\n\/**\n * A trait for classes that take a platform file system path factory as a\n * dependency.\n *\/\ntrait PlatformFileSystemPathFactoryTrait\n{\n    use PathFactoryTrait;\n\n    \/**\n     * @return PathFactoryInterface\n     *\/\n    protected function createDefaultPathFactory()\n    {\n        return new PlatformFileSystemPathFactory;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null]},{"name":"Eloquent\/Pathogen\/FileSystem\/Factory\/FileSystemPathFactory.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\FileSystem\\Factory;\n\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * A path factory that produces file system paths by inspecting the supplied\n * string, and determining the most suitable path type to use.\n *\/\nclass FileSystemPathFactory extends AbstractFileSystemPathFactory\n{\n    \/**\n     * Creates a new path instance from its string representation.\n     *\n     * @param string $path The string representation of the path.\n     *\n     * @return PathInterface The newly created path instance.\n     *\/\n    public function create($path)\n    {\n        if (preg_match('\/^([a-zA-Z]):\/', $path)) {\n            return $this->windowsFactory()->create($path);\n        }\n\n        return $this->unixFactory()->create($path);\n    }\n\n    \/**\n     * Creates a new path instance from a set of path atoms.\n     *\n     * Unless otherwise specified, created paths will be absolute, and have no\n     * trailing separator.\n     *\n     * @param mixed<string> $atoms                The path atoms.\n     * @param boolean|null  $isAbsolute           True if the path is absolute.\n     * @param boolean|null  $hasTrailingSeparator True if the path has a\n     *     trailing separator.\n     *\n     * @return PathInterface                     The newly created path instance.\n     * @throws InvalidPathAtomExceptionInterface If any of the supplied atoms\n     *     are invalid.\n     *\/\n    public function createFromAtoms(\n        $atoms,\n        $isAbsolute = null,\n        $hasTrailingSeparator = null\n    ) {\n        return $this->unixFactory()->createFromAtoms(\n            $atoms,\n            $isAbsolute,\n            $hasTrailingSeparator\n        );\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,1,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,1,null,1,null,null]},{"name":"Eloquent\/Pathogen\/FileSystem\/Factory\/FileSystemPathFactoryInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\FileSystem\\Factory;\n\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\nuse Eloquent\\Pathogen\\Factory\\PathFactoryInterface;\n\n\/**\n * The interface implemented by path factories that deal with file system paths.\n *\/\ninterface FileSystemPathFactoryInterface extends PathFactoryInterface\n{\n    \/**\n     * Create a path representing the current working directory.\n     *\n     * @return AbsolutePathInterface A new path instance representing the\n     *     current working directory path.\n     *\/\n    public function createWorkingDirectoryPath();\n\n    \/**\n     * Create a path representing the system temporary directory.\n     *\n     * @return AbsolutePathInterface A new path instance representing the system\n     *     default temporary directory path.\n     *\/\n    public function createTemporaryDirectoryPath();\n\n    \/**\n     * Create a path representing a suitable for use as the location for a new\n     * temporary file or directory.\n     *\n     * This path is not guaranteed to be unused, but collisions are fairly\n     * unlikely.\n     *\n     * @param string|null $prefix A string to use as a prefix for the path name.\n     *\n     * @return AbsolutePathInterface A new path instance representing the new\n     *     temporary path.\n     *\/\n    public function createTemporaryPath($prefix = null);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/FileSystem\/Factory\/PlatformFileSystemPathFactory.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\FileSystem\\Factory;\n\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * A path factory that produces file system paths whose type correlates to the\n * platform on which the code is running.\n *\/\nclass PlatformFileSystemPathFactory extends AbstractFileSystemPathFactory\n{\n    \/**\n     * Creates a new path instance from its string representation.\n     *\n     * @param string $path The string representation of the path.\n     *\n     * @return PathInterface The newly created path instance.\n     *\/\n    public function create($path)\n    {\n        return $this->factoryByPlatform()->create($path);\n    }\n\n    \/**\n     * Creates a new path instance from a set of path atoms.\n     *\n     * Unless otherwise specified, created paths will be absolute, and have no\n     * trailing separator.\n     *\n     * @param mixed<string> $atoms                The path atoms.\n     * @param boolean|null  $isAbsolute           True if the path is absolute.\n     * @param boolean|null  $hasTrailingSeparator True if the path has a\n     *     trailing separator.\n     *\n     * @return PathInterface                     The newly created path instance.\n     * @throws InvalidPathAtomExceptionInterface If any of the supplied atoms\n     *     are invalid.\n     *\/\n    public function createFromAtoms(\n        $atoms,\n        $isAbsolute = null,\n        $hasTrailingSeparator = null\n    ) {\n        return $this->factoryByPlatform()->createFromAtoms(\n            $atoms,\n            $isAbsolute,\n            $hasTrailingSeparator\n        );\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,2,2,null,2,null,null]},{"name":"Eloquent\/Pathogen\/FileSystem\/FileSystemPathInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\FileSystem;\n\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * The interface implemented by all file system paths.\n *\/\ninterface FileSystemPathInterface extends PathInterface\n{\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/FileSystem\/Normalizer\/FileSystemPathNormalizer.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\FileSystem\\Normalizer;\n\nuse Eloquent\\Pathogen\\Normalizer\\PathNormalizer;\nuse Eloquent\\Pathogen\\Normalizer\\PathNormalizerInterface;\nuse Eloquent\\Pathogen\\PathInterface;\nuse Eloquent\\Pathogen\\Windows\\Normalizer\\WindowsPathNormalizer;\nuse Eloquent\\Pathogen\\Windows\\WindowsPathInterface;\nuse Eloquent\\Pathogen\\Unix\\Factory\\UnixPathFactory;\n\n\/**\n * A path normalizer capable or normalizing any type of file system path.\n *\/\nclass FileSystemPathNormalizer implements PathNormalizerInterface\n{\n    \/**\n     * Construct a new file system path normalizer.\n     *\n     * @param PathNormalizerInterface|null $unixNormalizer The path normalizer\n     *     to use for Unix paths.\n     * @param PathNormalizerInterface|null $windowsNormalizer The path\n     *     normalizer to use for Windows paths.\n     *\/\n    public function __construct(\n        PathNormalizerInterface $unixNormalizer = null,\n        PathNormalizerInterface $windowsNormalizer = null\n    ) {\n        if (null === $unixNormalizer) {\n            $unixNormalizer = new PathNormalizer(\n                new UnixPathFactory\n            );\n        }\n        if (null === $windowsNormalizer) {\n            $windowsNormalizer = new WindowsPathNormalizer;\n        }\n\n        $this->unixNormalizer = $unixNormalizer;\n        $this->windowsNormalizer = $windowsNormalizer;\n    }\n\n    \/**\n     * Get the path normalizer used for Unix paths.\n     *\n     * @return PathNormalizerInterface The path normalizer used for Unix paths.\n     *\/\n    public function unixNormalizer()\n    {\n        return $this->unixNormalizer;\n    }\n\n    \/**\n     * Get the path normalizer used for Windows paths.\n     *\n     * @return PathNormalizerInterface The path normalizer used for Windows\n     *     paths.\n     *\/\n    public function windowsNormalizer()\n    {\n        return $this->windowsNormalizer;\n    }\n\n    \/**\n     * Normalize the supplied path to its most canonical form.\n     *\n     * @param PathInterface $path The path to normalize.\n     *\n     * @return PathInterface The normalized path.\n     *\/\n    public function normalize(PathInterface $path)\n    {\n        if ($path instanceof WindowsPathInterface) {\n            return $this->windowsNormalizer()->normalize($path);\n        }\n\n        return $this->unixNormalizer()->normalize($path);\n    }\n\n    private $unixNormalizer;\n    private $windowsNormalizer;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,1,null,1,1,4,1,1,null,4,4,4,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,null,null,2,1,null,null,1,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/FileSystem\/RelativeFileSystemPathInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\FileSystem;\n\nuse Eloquent\\Pathogen\\RelativePathInterface;\n\n\/**\n * The interface implemented by relative file system paths.\n *\/\ninterface RelativeFileSystemPathInterface extends\n    RelativePathInterface,\n    FileSystemPathInterface\n{\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/FileSystem\/Resolver\/WorkingDirectoryResolver.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\FileSystem\\Resolver;\n\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\nuse Eloquent\\Pathogen\\FileSystem\\Factory\\FileSystemPathFactoryInterface;\nuse Eloquent\\Pathogen\\FileSystem\\Factory\\PlatformFileSystemPathFactory;\nuse Eloquent\\Pathogen\\Resolver\\BoundPathResolver;\nuse Eloquent\\Pathogen\\Resolver\\PathResolverInterface;\n\n\/**\n * A bound path resolver for resolving file system paths against the current\n * working directory.\n *\/\nclass WorkingDirectoryResolver extends BoundPathResolver\n{\n    \/**\n     * Construct a new working directory path resolver.\n     *\n     * @param AbsolutePathInterface|null          $workingDirectoryPath The working directory path.\n     * @param PathResolverInterface|null          $resolver             The path resolver to use.\n     * @param FileSystemPathFactoryInterface|null $factory              The path factory to use.\n     *\/\n    public function __construct(\n        AbsolutePathInterface $workingDirectoryPath = null,\n        PathResolverInterface $resolver = null,\n        FileSystemPathFactoryInterface $factory = null\n    ) {\n        if (null === $factory) {\n            $factory = new PlatformFileSystemPathFactory;\n        }\n\n        $this->factory = $factory;\n\n        if (null === $workingDirectoryPath) {\n            $workingDirectoryPath = $this->factory()\n                ->createWorkingDirectoryPath();\n        }\n\n        parent::__construct($workingDirectoryPath, $resolver);\n    }\n\n    \/**\n     * Get the path factory used by this resolver.\n     *\n     * @return FileSystemPathFactoryInterface The path factory.\n     *\/\n    public function factory()\n    {\n        return $this->factory;\n    }\n\n    private $factory;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,5,2,2,null,5,null,5,2,2,2,null,5,5,null,null,null,null,null,null,null,null,4,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Normalizer\/PathNormalizer.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Normalizer;\n\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\nuse Eloquent\\Pathogen\\Factory\\PathFactory;\nuse Eloquent\\Pathogen\\Factory\\PathFactoryInterface;\nuse Eloquent\\Pathogen\\PathInterface;\nuse Eloquent\\Pathogen\\RelativePathInterface;\n\n\/**\n * A path normalizer suitable for generic, Unix-style path instances.\n *\/\nclass PathNormalizer implements PathNormalizerInterface\n{\n    \/**\n     * Construct a new path normalizer.\n     *\n     * @param PathFactoryInterface|null $factory The path factory to use.\n     *\/\n    public function __construct(PathFactoryInterface $factory = null)\n    {\n        if (null === $factory) {\n            $factory = new PathFactory;\n        }\n\n        $this->factory = $factory;\n    }\n\n    \/**\n     * Get the path factory used by this normalizer.\n     *\n     * @return PathFactoryInterface The path factory.\n     *\/\n    public function factory()\n    {\n        return $this->factory;\n    }\n\n    \/**\n     * Normalize the supplied path to its most canonical form.\n     *\n     * @param PathInterface $path The path to normalize.\n     *\n     * @return PathInterface The normalized path.\n     *\/\n    public function normalize(PathInterface $path)\n    {\n        if ($path instanceof AbsolutePathInterface) {\n            return $this->normalizeAbsolutePath($path);\n        }\n\n        return $this->normalizeRelativePath($path);\n    }\n\n    \/**\n     * @param AbsolutePathInterface $path\n     *\n     * @return AbsolutePathInterface\n     *\/\n    protected function normalizeAbsolutePath(AbsolutePathInterface $path)\n    {\n        return $this->factory()->createFromAtoms(\n            $this->normalizeAbsolutePathAtoms($path->atoms()),\n            true,\n            false\n        );\n    }\n\n    \/**\n     * @param RelativePathInterface $path\n     *\n     * @return RelativePathInterface\n     *\/\n    protected function normalizeRelativePath(RelativePathInterface $path)\n    {\n        return $this->factory()->createFromAtoms(\n            $this->normalizeRelativePathAtoms($path->atoms()),\n            false,\n            false\n        );\n    }\n\n    \/**\n     * @param array<string> $atoms\n     *\n     * @return array<string>\n     *\/\n    protected function normalizeAbsolutePathAtoms(array $atoms)\n    {\n        $resultingAtoms = array();\n        foreach ($atoms as $atom) {\n            if (PathInterface::PARENT_ATOM === $atom) {\n                array_pop($resultingAtoms);\n            } elseif (PathInterface::SELF_ATOM !== $atom) {\n                $resultingAtoms[] = $atom;\n            }\n        }\n\n        return $resultingAtoms;\n    }\n\n    \/**\n     * @param array<string> $atoms\n     *\n     * @return array<string>\n     *\/\n    protected function normalizeRelativePathAtoms(array $atoms)\n    {\n        $resultingAtoms = array();\n        $resultingAtomsCount = 0;\n        $numAtoms = count($atoms);\n\n        for ($i = 0; $i < $numAtoms; $i++) {\n            if (PathInterface::SELF_ATOM !== $atoms[$i]) {\n                $resultingAtoms[] = $atoms[$i];\n                $resultingAtomsCount++;\n            }\n\n            if (\n                $resultingAtomsCount > 1 &&\n                PathInterface::PARENT_ATOM === $resultingAtoms[$resultingAtomsCount - 1] &&\n                PathInterface::PARENT_ATOM !== $resultingAtoms[$resultingAtomsCount - 2]\n            ) {\n                array_splice($resultingAtoms, $resultingAtomsCount - 2, 2);\n                $resultingAtomsCount -= 2;\n            }\n        }\n\n        if (count($resultingAtoms) < 1) {\n            $resultingAtoms = array(PathInterface::SELF_ATOM);\n        }\n\n        return $resultingAtoms;\n    }\n\n    private $factory;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,51,51,51,null,51,51,null,null,null,null,null,null,null,null,50,null,null,null,null,null,null,null,null,null,null,null,50,19,null,null,31,null,null,null,null,null,null,null,null,null,19,19,19,null,19,null,null,null,null,null,null,null,null,null,31,31,31,null,31,null,null,null,null,null,null,null,null,null,19,19,19,13,19,15,15,19,null,19,null,null,null,null,null,null,null,null,null,31,31,31,null,31,31,29,29,29,null,null,31,31,19,31,15,15,15,31,null,31,4,4,null,31,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Normalizer\/PathNormalizerInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Normalizer;\n\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * The interface implemented by path normalizers.\n *\/\ninterface PathNormalizerInterface\n{\n    \/**\n     * Normalize the supplied path to its most canonical form.\n     *\n     * @param PathInterface $path The path to normalize.\n     *\n     * @return PathInterface The normalized path.\n     *\/\n    public function normalize(PathInterface $path);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/PathInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen;\n\n\/**\n * The interface implemented by all Pathogen paths.\n *\/\ninterface PathInterface\n{\n    \/**\n     * Get the atoms of this path.\n     *\n     * For example, the path '\/foo\/bar' has the atoms 'foo' and 'bar'.\n     *\n     * @return array<integer,string> The atoms of this path as an array of\n     * strings.\n     *\/\n    public function atoms();\n\n    \/**\n     * Get a subset of the atoms of this path.\n     *\n     * @param integer      $index  The index of the first atom.\n     * @param integer|null $length The maximum number of atoms.\n     *\n     * @return array<integer,string> An array of strings representing the subset\n     *     of path atoms.\n     *\/\n    public function sliceAtoms($index, $length = null);\n\n    \/**\n     * Determine if this path has any atoms.\n     *\n     * @return boolean True if this path has at least one atom.\n     *\/\n    public function hasAtoms();\n\n    \/**\n     * Determine if this path has a trailing separator.\n     *\n     * @return boolean True if this path has a trailing separator.\n     *\/\n    public function hasTrailingSeparator();\n\n    \/**\n     * Generate a string representation of this path.\n     *\n     * @return string A string representation of this path.\n     *\/\n    public function string();\n\n    \/**\n     * Generate a string representation of this path.\n     *\n     * @return string A string representation of this path.\n     *\/\n    public function __toString();\n\n    \/**\n     * Get this path's name.\n     *\n     * @return string The last path atom if one exists, otherwise an empty\n     *     string.\n     *\/\n    public function name();\n\n    \/**\n     * Get this path's name atoms.\n     *\n     * For example, the path name 'foo.bar' has the atoms 'foo' and 'bar'.\n     *\n     * @return array<integer,string> The atoms of this path's name as an array\n     *     of strings.\n     *\/\n    public function nameAtoms();\n\n    \/**\n     * Get a subset of this path's name atoms.\n     *\n     * @param integer      $index  The index of the first atom.\n     * @param integer|null $length The maximum number of atoms.\n     *\n     * @return array<integer,string> An array of strings representing the subset\n     *     of path name atoms.\n     *\/\n    public function sliceNameAtoms($index, $length = null);\n\n    \/**\n     * Get this path's name, excluding the last extension.\n     *\n     * @return string The last atom of this path, excluding the last extension.\n     *     If this path has no atoms, an empty string is returned.\n     *\/\n    public function nameWithoutExtension();\n\n    \/**\n     * Get this path's name, excluding all extensions.\n     *\n     * @return string The last atom of this path, excluding any extensions. If\n     *     this path has no atoms, an empty string is returned.\n     *\/\n    public function namePrefix();\n\n    \/**\n     * Get all of this path's extensions.\n     *\n     * @return string|null The extensions of this path's last atom. If the last\n     *     atom has no extensions, or this path has no atoms, this method will\n     *     return null.\n     *\/\n    public function nameSuffix();\n\n    \/**\n     * Get this path's last extension.\n     *\n     * @return string|null The last extension of this path's last atom. If the\n     *     last atom has no extensions, or this path has no atoms, this method\n     *     will return null.\n     *\/\n    public function extension();\n\n    \/**\n     * Determine if this path has any extensions.\n     *\n     * @return boolean True if this path's last atom has any extensions.\n     *\/\n    public function hasExtension();\n\n    \/**\n     * Determine if this path contains a substring.\n     *\n     * @param string       $needle        The substring to search for.\n     * @param boolean|null $caseSensitive True if case sensitive.\n     *\n     * @return boolean\n     *\/\n    public function contains($needle, $caseSensitive = null);\n\n    \/**\n     * Determine if this path starts with a substring.\n     *\n     * @param string       $needle        The substring to search for.\n     * @param boolean|null $caseSensitive True if case sensitive.\n     *\n     * @return boolean\n     *\/\n    public function startsWith($needle, $caseSensitive = null);\n\n    \/**\n     * Determine if this path ends with a substring.\n     *\n     * @param string       $needle        The substring to search for.\n     * @param boolean|null $caseSensitive True if case sensitive.\n     *\n     * @return boolean\n     *\/\n    public function endsWith($needle, $caseSensitive = null);\n\n    \/**\n     * Determine if this path matches a wildcard pattern.\n     *\n     * @param string       $pattern       The pattern to check against.\n     * @param boolean|null $caseSensitive True if case sensitive.\n     * @param integer|null $flags         Additional flags.\n     *\n     * @return boolean\n     *\/\n    public function matches($pattern, $caseSensitive = null, $flags = null);\n\n    \/**\n     * Determine if this path matches a regular expression.\n     *\n     * @param string       $pattern  The pattern to check against.\n     * @param array|null   &$matches Populated with the pattern matches.\n     * @param integer|null $flags    Additional flags.\n     * @param integer|null $offset   Start searching from this byte offset.\n     *\n     * @return boolean\n     *\/\n    public function matchesRegex(\n        $pattern,\n        array &$matches = null,\n        $flags = null,\n        $offset = null\n    );\n\n    \/**\n     * Determine if this path's name contains a substring.\n     *\n     * @param string       $needle        The substring to search for.\n     * @param boolean|null $caseSensitive True if case sensitive.\n     *\n     * @return boolean\n     *\/\n    public function nameContains($needle, $caseSensitive = null);\n\n    \/**\n     * Determine if this path's name starts with a substring.\n     *\n     * @param string       $needle        The substring to search for.\n     * @param boolean|null $caseSensitive True if case sensitive.\n     *\n     * @return boolean\n     *\/\n    public function nameStartsWith($needle, $caseSensitive = null);\n\n    \/**\n     * Determine if this path's name matches a wildcard pattern.\n     *\n     * @param string       $pattern       The pattern to check against.\n     * @param boolean|null $caseSensitive True if case sensitive.\n     * @param integer|null $flags         Additional flags.\n     *\n     * @return boolean\n     *\/\n    public function nameMatches($pattern, $caseSensitive = null, $flags = null);\n\n    \/**\n     * Determine if this path's name matches a regular expression.\n     *\n     * @param string       $pattern  The pattern to check against.\n     * @param array|null   &$matches Populated with the pattern matches.\n     * @param integer|null $flags    Additional flags.\n     * @param integer|null $offset   Start searching from this byte offset.\n     *\n     * @return boolean\n     *\/\n    public function nameMatchesRegex(\n        $pattern,\n        array &$matches = null,\n        $flags = null,\n        $offset = null\n    );\n\n    \/**\n     * Get the parent of this path a specified number of levels up.\n     *\n     * @param integer|null $numLevels The number of\n     *     levels up. Defaults to 1.\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the parent.\n     *\n     * @return PathInterface The parent of this path $numLevels up.\n     *\/\n    public function parent(\n        $numLevels = null,\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    );\n\n    \/**\n     * Strips the trailing slash from this path.\n     *\n     * @return PathInterface A new path instance with the trailing slash removed\n     *     from this path. If this path has no trailing slash, the path is\n     *     returned unmodified.\n     *\/\n    public function stripTrailingSlash();\n\n    \/**\n     * Strips the last extension from this path.\n     *\n     * @return PathInterface A new path instance with the last extension removed\n     *     from this path. If this path has no extensions, the path is returned\n     *     unmodified.\n     *\/\n    public function stripExtension();\n\n    \/**\n     * Strips all extensions from this path.\n     *\n     * @return PathInterface A new path instance with all extensions removed\n     *     from this path. If this path has no extensions, the path is returned\n     *     unmodified.\n     *\/\n    public function stripNameSuffix();\n\n    \/**\n     * Joins one or more atoms to this path.\n     *\n     * @param string     $atom            A path atom to append.\n     * @param string,... $additionalAtoms Additional path atoms to append.\n     *\n     * @return PathInterface A new path with the supplied atom(s) suffixed to\n     *     this path.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If any joined atoms\n     *     are invalid.\n     *\/\n    public function joinAtoms($atom);\n\n    \/**\n     * Joins a sequence of atoms to this path.\n     *\n     * @param mixed<string> $atoms The path atoms to append.\n     *\n     * @return PathInterface A new path with the supplied sequence of atoms\n     *     suffixed to this path.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If any joined atoms\n     *     are invalid.\n     *\/\n    public function joinAtomSequence($atoms);\n\n    \/**\n     * Joins the supplied path to this path.\n     *\n     * @param RelativePathInterface $path The path whose atoms should be joined\n     *     to this path.\n     *\n     * @return PathInterface A new path with the supplied path suffixed to this\n     *     path.\n     *\/\n    public function join(RelativePathInterface $path);\n\n    \/**\n     * Adds a trailing slash to this path.\n     *\n     * @return PathInterface A new path instance with a trailing slash suffixed\n     *     to this path.\n     *\/\n    public function joinTrailingSlash();\n\n    \/**\n     * Joins one or more extensions to this path.\n     *\n     * @param string     $extension            An extension to append.\n     * @param string,... $additionalExtensions Additional extensions to append.\n     *\n     * @return PathInterface A new path instance with the supplied extensions\n     *     suffixed to this path.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If the suffixed\n     *     extensions cause the atom to be invalid.\n     *\/\n    public function joinExtensions($extension);\n\n    \/**\n     * Joins a sequence of extensions to this path.\n     *\n     * @param mixed<string> $extensions\n     *\n     * @return PathInterface A new path instance with the supplied extensions\n     *     suffixed to this path.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If the suffixed\n     *     extensions cause the atom to be invalid.\n     *\/\n    public function joinExtensionSequence($extensions);\n\n    \/**\n     * Suffixes this path's name with a supplied string.\n     *\n     * @param string $suffix The string to suffix to the path name.\n     *\n     * @return PathInterface A new path instance with the supplied string\n     *     suffixed to the last path atom.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If the suffix causes\n     *     the atom to be invalid.\n     *\/\n    public function suffixName($suffix);\n\n    \/**\n     * Prefixes this path's name with a supplied string.\n     *\n     * @param string $prefix The string to prefix to the path name.\n     *\n     * @return PathInterface A new path instance with the supplied string\n     *     prefixed to the last path atom.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If the prefix causes\n     *     the atom to be invalid.\n     *\/\n    public function prefixName($prefix);\n\n    \/**\n     * Replace a section of this path with the supplied atom sequence.\n     *\n     * @param integer       $index       The start index of the replacement.\n     * @param mixed<string> $replacement The replacement atom sequence.\n     * @param integer|null  $length      The number of atoms to replace. If\n     *     $length is null, the entire remainder of the path will be replaced.\n     *\n     * @return PathInterface A new path instance that has a portion of this\n     *     path's atoms replaced with a different sequence of atoms.\n     *\/\n    public function replace($index, $replacement, $length = null);\n\n    \/**\n     * Replace this path's name.\n     *\n     * @param string $name The new path name.\n     *\n     * @return PathInterface A new path instance with the supplied name\n     *     replacing the existing one.\n     *\/\n    public function replaceName($name);\n\n    \/**\n     * Replace this path's name, but keep the last extension.\n     *\n     * @param string $nameWithoutExtension The replacement string.\n     *\n     * @return PathInterface A new path instance with the supplied name\n     *     replacing the portion of the existing name preceding the last\n     *     extension.\n     *\/\n    public function replaceNameWithoutExtension($nameWithoutExtension);\n\n    \/**\n     * Replace this path's name, but keep any extensions.\n     *\n     * @param string $namePrefix The replacement string.\n     *\n     * @return PathInterface A new path instance with the supplied name prefix\n     *     replacing the existing one.\n     *\/\n    public function replaceNamePrefix($namePrefix);\n\n    \/**\n     * Replace all of this path's extensions.\n     *\n     * @param string|null $nameSuffix The replacement string, or null to remove\n     *     all extensions.\n     *\n     * @return PathInterface A new path instance with the supplied name suffix\n     *     replacing the existing one.\n     *\/\n    public function replaceNameSuffix($nameSuffix);\n\n    \/**\n     * Replace this path's last extension.\n     *\n     * @param string|null $extension The replacement string, or null to remove\n     *     the last extension.\n     *\n     * @return PathInterface A new path instance with the supplied extension\n     *     replacing the existing one.\n     *\/\n    public function replaceExtension($extension);\n\n    \/**\n     * Replace a section of this path's name with the supplied name atom\n     * sequence.\n     *\n     * @param integer       $index       The start index of the replacement.\n     * @param mixed<string> $replacement The replacement name atom sequence.\n     * @param integer|null  $length      The number of atoms to replace. If\n     *     $length is null, the entire remainder of the path name will be\n     *     replaced.\n     *\n     * @return PathInterface A new path instance that has a portion of this\n     *     name's atoms replaced with a different sequence of atoms.\n     *\/\n    public function replaceNameAtoms($index, $replacement, $length = null);\n\n    \/**\n     * Normalize this path to its most canonical form.\n     *\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer\n     *\n     * @return PathInterface The normalized path.\n     *\/\n    public function normalize(\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    );\n\n    \/**\n     * The character used to separate path atoms.\n     *\/\n    const ATOM_SEPARATOR = '\/';\n\n    \/**\n     * The character used to separate path name atoms.\n     *\/\n    const EXTENSION_SEPARATOR = '.';\n\n    \/**\n     * The atom used to represent 'parent'.\n     *\/\n    const PARENT_ATOM = '..';\n\n    \/**\n     * The atom used to represent 'self'.\n     *\/\n    const SELF_ATOM = '.';\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/RelativePath.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen;\n\n\/**\n * Represents a relative path.\n *\/\nclass RelativePath extends AbstractPath implements RelativePathInterface\n{\n    \/\/ Implementation of RelativePathInterface =================================\n\n    \/**\n     * Determine whether this path is the self path.\n     *\n     * The self path is a relative path with a single self atom (i.e. a dot\n     * '.').\n     *\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return boolean True if this path is the self path.\n     *\/\n    public function isSelf(\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    ) {\n        if (null === $normalizer) {\n            $normalizer = $this->createDefaultNormalizer();\n        }\n\n        $atoms = $this->normalize($normalizer)->atoms();\n\n        return 1 === count($atoms) && static::SELF_ATOM === $atoms[0];\n    }\n\n    \/\/ Implementation details ==================================================\n\n    \/**\n     * @param mixed<string> $atoms\n     *\n     * @return array<string>\n     *\/\n    protected function normalizeAtoms($atoms)\n    {\n        $atoms = parent::normalizeAtoms($atoms);\n        if (count($atoms) < 1) {\n            throw new Exception\\EmptyPathException;\n        }\n\n        return $atoms;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,12,12,12,null,12,null,12,null,null,null,null,null,null,null,null,null,null,null,882,836,3,null,null,833,null,null]},{"name":"Eloquent\/Pathogen\/RelativePathInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen;\n\n\/**\n * The interface implemented by relative paths.\n *\/\ninterface RelativePathInterface extends PathInterface\n{\n    \/**\n     * Determine whether this path is the self path.\n     *\n     * The self path is a relative path with a single self atom (i.e. a dot\n     * '.').\n     *\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return boolean True if this path is the self path.\n     *\/\n    public function isSelf(\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    );\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Resolver\/BoundPathResolver.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Resolver;\n\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * A path resolver that wraps another path resolver with a fixed base path.\n *\/\nclass BoundPathResolver implements BoundPathResolverInterface\n{\n    \/**\n     * Construct a new bound path resolver.\n     *\n     * @param AbsolutePathInterface      $basePath The base path.\n     * @param PathResolverInterface|null $resolver The path resolver to use.\n     *\/\n    public function __construct(\n        AbsolutePathInterface $basePath,\n        PathResolverInterface $resolver = null\n    ) {\n        if (null === $resolver) {\n            $resolver = new PathResolver;\n        }\n\n        $this->basePath = $basePath;\n        $this->resolver = $resolver;\n    }\n\n    \/**\n     * Get the base path used by this resolver.\n     *\n     * @returns AbsolutePathInterface The base path.\n     *\/\n    public function basePath()\n    {\n        return $this->basePath;\n    }\n\n    \/**\n     * Get the resolver used internally by this resolver.\n     *\n     * @returns PathResolverInterface The inner path resolver.\n     *\/\n    public function resolver()\n    {\n        return $this->resolver;\n    }\n\n    \/**\n     * Resolve a path against the base path.\n     *\n     * @param PathInterface $path The path to resolve.\n     *\n     * @return AbsolutePathInterface The resolved path.\n     *\/\n    public function resolve(PathInterface $path)\n    {\n        return $this->resolver()->resolve($this->basePath(), $path);\n    }\n\n    private $basePath;\n    private $resolver;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,2,2,null,4,4,4,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,4,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Resolver\/BoundPathResolverInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Resolver;\n\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * The interface implemented by path resolvers with a fixed base path.\n *\/\ninterface BoundPathResolverInterface\n{\n    \/**\n     * Resolve a path against the base path.\n     *\n     * @param PathInterface $path The path to resolve.\n     *\n     * @return AbsolutePathInterface The resolved path.\n     *\/\n    public function resolve(PathInterface $path);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Resolver\/Consumer\/NormalizingPathResolverTrait.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Resolver\\Consumer;\n\nuse Eloquent\\Pathogen\\Resolver\\NormalizingPathResolver;\n\n\/**\n * A trait for classes that take a normalizing path resolver as a dependency.\n *\/\ntrait NormalizingPathResolverTrait\n{\n    use PathResolverTrait;\n\n    \/**\n     * @return PathResolverInterface\n     *\/\n    protected function createDefaultPathResolver()\n    {\n        return new NormalizingPathResolver;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null]},{"name":"Eloquent\/Pathogen\/Resolver\/Consumer\/PathResolverTrait.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Resolver\\Consumer;\n\nuse Eloquent\\Pathogen\\Resolver\\PathResolver;\nuse Eloquent\\Pathogen\\Resolver\\PathResolverInterface;\n\n\/**\n * A trait for classes that take a path resolver as a dependency.\n *\/\ntrait PathResolverTrait\n{\n    \/**\n     * Set the path resolver.\n     *\n     * @param PathResolverInterface $pathResolver\n     *\/\n    public function setPathResolver(PathResolverInterface $pathResolver)\n    {\n        $this->pathResolver = $pathResolver;\n    }\n\n    \/**\n     * Get the path resolver.\n     *\n     * @return PathResolverInterface\n     *\/\n    public function pathResolver()\n    {\n        if (null === $this->pathResolver) {\n            $this->pathResolver = $this->createDefaultPathResolver();\n        }\n\n        return $this->pathResolver;\n    }\n\n    \/**\n     * @return PathResolverInterface\n     *\/\n    protected function createDefaultPathResolver()\n    {\n        return new PathResolver;\n    }\n\n    private $pathResolver;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,2,null,null,null,null,null,null,null,null,4,2,2,null,4,null,null,null,null,null,null,null,1,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Resolver\/NormalizingPathResolver.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Resolver;\n\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\nuse Eloquent\\Pathogen\\Normalizer\\PathNormalizer;\nuse Eloquent\\Pathogen\\Normalizer\\PathNormalizerInterface;\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * A path resolver that wraps another path resolver and automatically normalizes\n * the result.\n *\/\nclass NormalizingPathResolver implements PathResolverInterface\n{\n    \/**\n     * Construct a new normalizing path resolver.\n     *\n     * @param PathNormalizerInterface|null $normalizer The path normalizer to use.\n     * @param PathResolverInterface|null   $resolver   The path resolver to use.\n     *\/\n    public function __construct(\n        PathNormalizerInterface $normalizer = null,\n        PathResolverInterface $resolver = null\n    ) {\n        if (null === $normalizer) {\n            $normalizer = new PathNormalizer;\n        }\n        if (null === $resolver) {\n            $resolver = new PathResolver;\n        }\n\n        $this->normalizer = $normalizer;\n        $this->resolver = $resolver;\n    }\n\n    \/**\n     * Get the path normalizer used by this resolver.\n     *\n     * @return PathNormalizerInterface The path normalizer.\n     *\/\n    public function normalizer()\n    {\n        return $this->normalizer;\n    }\n\n    \/**\n     * Get the resolver used internally by this resolver.\n     *\n     * @returns PathResolverInterface The inner path resolver.\n     *\/\n    public function resolver()\n    {\n        return $this->resolver;\n    }\n\n    \/**\n     * Resolve a path against a given base path.\n     *\n     * @param AbsolutePathInterface $basePath The base path.\n     * @param PathInterface         $path     The path to resolve.\n     *\n     * @return AbsolutePathInterface The resolved path.\n     *\/\n    public function resolve(\n        AbsolutePathInterface $basePath,\n        PathInterface $path\n    ) {\n        return $this->resolver()\n            ->resolve($basePath, $path)\n            ->normalize($this->normalizer());\n    }\n\n    private $normalizer;\n    private $resolver;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,5,3,3,5,3,3,null,5,5,5,null,null,null,null,null,null,null,null,4,null,null,null,null,null,null,null,null,null,4,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,2,2,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Resolver\/PathResolver.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Resolver;\n\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * A path resolver suitable for resolving generic, Unix-style paths.\n *\/\nclass PathResolver implements PathResolverInterface\n{\n    \/**\n     * Resolve a path against a given base path.\n     *\n     * @param AbsolutePathInterface $basePath The base path.\n     * @param PathInterface         $path     The path to resolve.\n     *\n     * @return AbsolutePathInterface The resolved path.\n     *\/\n    public function resolve(\n        AbsolutePathInterface $basePath,\n        PathInterface $path\n    ) {\n        if ($path instanceof AbsolutePathInterface) {\n            return $path;\n        }\n\n        return $basePath->join($path);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,20,4,null,null,16,null,null]},{"name":"Eloquent\/Pathogen\/Resolver\/PathResolverInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Resolver;\n\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * The interface implemented by path resolvers.\n *\/\ninterface PathResolverInterface\n{\n    \/**\n     * Resolve a path against a given base path.\n     *\n     * @param AbsolutePathInterface $basePath The base path.\n     * @param PathInterface         $path     The path to resolve.\n     *\n     * @return AbsolutePathInterface The resolved path.\n     *\/\n    public function resolve(\n        AbsolutePathInterface $basePath,\n        PathInterface $path\n    );\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Unix\/AbsoluteUnixPath.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Unix;\n\nuse Eloquent\\Pathogen\\FileSystem\\AbstractAbsoluteFileSystemPath;\n\n\/**\n * Represents an absolute Unix path.\n *\/\nclass AbsoluteUnixPath extends AbstractAbsoluteFileSystemPath implements\n    AbsoluteUnixPathInterface\n{\n    \/**\n     * @param mixed<string> $atoms\n     * @param boolean       $isAbsolute\n     * @param boolean|null  $hasTrailingSeparator\n     *\n     * @return PathInterface\n     *\/\n    protected function createPath(\n        $atoms,\n        $isAbsolute,\n        $hasTrailingSeparator = null\n    ) {\n        if ($isAbsolute) {\n            return new static($atoms, $hasTrailingSeparator);\n        }\n\n        return new RelativeUnixPath($atoms, $hasTrailingSeparator);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,136,127,null,null,9,null,null]},{"name":"Eloquent\/Pathogen\/Unix\/AbsoluteUnixPathInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Unix;\n\nuse Eloquent\\Pathogen\\FileSystem\\AbsoluteFileSystemPathInterface;\n\n\/**\n * The interface implemented by absolute Unix paths.\n *\/\ninterface AbsoluteUnixPathInterface extends\n    AbsoluteFileSystemPathInterface,\n    UnixPathInterface\n{\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Unix\/Factory\/UnixPathFactory.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Unix\\Factory;\n\nuse Eloquent\\Pathogen\\Exception\\InvalidPathAtomExceptionInterface;\nuse Eloquent\\Pathogen\\Factory\\PathFactory;\nuse Eloquent\\Pathogen\\PathInterface;\nuse Eloquent\\Pathogen\\Unix\\AbsoluteUnixPath;\nuse Eloquent\\Pathogen\\Unix\\RelativeUnixPath;\n\n\/**\n * A path factory that creates Unix path instances.\n *\/\nclass UnixPathFactory extends PathFactory\n{\n    \/**\n     * Creates a new path instance from a set of path atoms.\n     *\n     * Unless otherwise specified, created paths will be absolute, and have no\n     * trailing separator.\n     *\n     * @param mixed<string> $atoms                The path atoms.\n     * @param boolean|null  $isAbsolute           True if the path is absolute.\n     * @param boolean|null  $hasTrailingSeparator True if the path has a\n     *     trailing separator.\n     *\n     * @return PathInterface                     The newly created path instance.\n     * @throws InvalidPathAtomExceptionInterface If any of the supplied atoms\n     *     are invalid.\n     *\/\n    public function createFromAtoms(\n        $atoms,\n        $isAbsolute = null,\n        $hasTrailingSeparator = null\n    ) {\n        if ($isAbsolute) {\n            return new AbsoluteUnixPath($atoms, $hasTrailingSeparator);\n        }\n\n        return new RelativeUnixPath($atoms, $hasTrailingSeparator);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,29,15,null,null,15,null,null]},{"name":"Eloquent\/Pathogen\/Unix\/RelativeUnixPath.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Unix;\n\nuse Eloquent\\Pathogen\\FileSystem\\AbstractRelativeFileSystemPath;\n\n\/**\n * Represents a relative Unix path.\n *\/\nclass RelativeUnixPath extends AbstractRelativeFileSystemPath implements\n    RelativeUnixPathInterface\n{\n    \/**\n     * @param mixed<string> $atoms\n     * @param boolean       $isAbsolute\n     * @param boolean|null  $hasTrailingSeparator\n     *\n     * @return PathInterface\n     *\/\n    protected function createPath(\n        $atoms,\n        $isAbsolute,\n        $hasTrailingSeparator = null\n    ) {\n        return new static($atoms, $hasTrailingSeparator);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,115,null,null]},{"name":"Eloquent\/Pathogen\/Unix\/RelativeUnixPathInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Unix;\n\nuse Eloquent\\Pathogen\\FileSystem\\RelativeFileSystemPathInterface;\n\n\/**\n * The interface implemented by relative Unix paths.\n *\/\ninterface RelativeUnixPathInterface extends\n    RelativeFileSystemPathInterface,\n    UnixPathInterface\n{\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Unix\/UnixPathInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Unix;\n\nuse Eloquent\\Pathogen\\FileSystem\\FileSystemPathInterface;\n\n\/**\n * The interface implemented by all Unix paths.\n *\/\ninterface UnixPathInterface extends FileSystemPathInterface\n{\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/AbsoluteWindowsPath.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows;\n\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\nuse Eloquent\\Pathogen\\Exception\\InvalidPathAtomCharacterException;\nuse Eloquent\\Pathogen\\Exception\\InvalidPathAtomExceptionInterface;\nuse Eloquent\\Pathogen\\Exception\\PathAtomContainsSeparatorException;\nuse Eloquent\\Pathogen\\FileSystem\\AbstractAbsoluteFileSystemPath;\nuse Eloquent\\Pathogen\\Normalizer\\PathNormalizerInterface;\n\n\/**\n * Represents an absolute Windows path.\n *\/\nclass AbsoluteWindowsPath extends AbstractAbsoluteFileSystemPath implements\n    AbsoluteWindowsPathInterface\n{\n    \/**\n     * Construct a new path instance.\n     *\n     * @param mixed<string> $atoms The path atoms.\n     * @param string|null   $drive The drive specifier, or null if the path has\n     *     no drive specifier.\n     * @param boolean|null $hasTrailingSeparator True if this path has a\n     *     trailing separator.\n     *\n     * @throws Exception\\InvalidDriveSpecifierException If the drive specifier\n     *     is invalid.\n     * @throws InvalidPathAtomExceptionInterface If any of the supplied path\n     *     atoms are invalid.\n     *\/\n    public function __construct($atoms, $drive, $hasTrailingSeparator = null)\n    {\n        if (null !== $drive && !preg_match('\/^[a-zA-Z]$\/', $drive)) {\n            throw new Exception\\InvalidDriveSpecifierException($drive);\n        }\n\n        parent::__construct($atoms, $hasTrailingSeparator);\n\n        $this->drive = $drive;\n    }\n\n    \/\/ Implementation of AbsoluteWindowsPathInterface ==========================\n\n    \/**\n     * Get this path's drive specifier.\n     *\n     * @return string|null The drive specifier, or null if this path does not\n     *     have a drive specifier.\n     *\/\n    public function drive()\n    {\n        return $this->drive;\n    }\n\n    \/**\n     * Determine whether this path has a drive specifier.\n     *\n     * @return boolean True is this path has a drive specifier.\n     *\/\n    public function hasDrive()\n    {\n        return null !== $this->drive();\n    }\n\n    \/**\n     * Joins the supplied drive specifier to this path.\n     *\n     * @return string|null $drive The drive specifier to use, or null to remove\n     *     the drive specifier.\n     *\n     * @return AbsoluteWindowsPathInterface A new path instance with the\n     *     supplied drive specifier joined to this path.\n     *\/\n    public function joinDrive($drive)\n    {\n        return $this->createPathWithDrive(\n            $this->atoms(),\n            $drive,\n            false\n        );\n    }\n\n    \/\/ Implementation of PathInterface =========================================\n\n    \/**\n     * Generate a string representation of this path.\n     *\n     * @return string A string representation of this path.\n     *\/\n    public function string()\n    {\n        $drive = $this->drive();\n        if (null !== $drive) {\n            return\n                $drive .\n                ':' .\n                static::ATOM_SEPARATOR .\n                implode(static::ATOM_SEPARATOR, $this->atoms()) .\n                ($this->hasTrailingSeparator() ? static::ATOM_SEPARATOR : '')\n            ;\n        }\n\n        return\n            static::ATOM_SEPARATOR .\n            implode(static::ATOM_SEPARATOR, $this->atoms()) .\n            ($this->hasTrailingSeparator() ? static::ATOM_SEPARATOR : '')\n        ;\n    }\n\n    \/\/ Implementation of AbsolutePathInterface =================================\n\n    \/**\n     * Determine if this path is the direct parent of the supplied path.\n     *\n     * @param AbsolutePathInterface        $path       The child path.\n     * @param PathNormalizerInterface|null $normalizer The normalizer to use\n     *     when determining the result.\n     *\n     * @return boolean True if this path is the direct parent of the supplied\n     *     path.\n     *\/\n    public function isParentOf(\n        AbsolutePathInterface $path,\n        PathNormalizerInterface $normalizer = null\n    ) {\n        if (null === $normalizer) {\n            $normalizer = $this->createDefaultNormalizer();\n        }\n\n        if (!$this->driveSpecifiersMatch($this, $path)) {\n            return false;\n        }\n\n        return parent::isParentOf($path, $normalizer);\n    }\n\n    \/**\n     * Determine if this path is an ancestor of the supplied path.\n     *\n     * @param AbsolutePathInterface        $path       The child path.\n     * @param PathNormalizerInterface|null $normalizer The normalizer to use\n     *     when determining the result.\n     *\n     * @return boolean True if this path is an ancestor of the supplied path.\n     *\/\n    public function isAncestorOf(\n        AbsolutePathInterface $path,\n        PathNormalizerInterface $normalizer = null\n    ) {\n        if (null === $normalizer) {\n            $normalizer = $this->createDefaultNormalizer();\n        }\n\n        if (!$this->driveSpecifiersMatch($this, $path)) {\n            return false;\n        }\n\n        return parent::isAncestorOf($path, $normalizer);\n    }\n\n    \/**\n     * Determine the shortest path from the supplied path to this path.\n     *\n     * For example, given path A equal to '\/foo\/bar', and path B equal to\n     * '\/foo\/baz', A relative to B would be '..\/bar'.\n     *\n     * @param AbsolutePathInterface $path The path that the generated path will\n     *     be relative to.\n     * @param PathNormalizerInterface|null $normalizer The normalizer to use\n     *     when determining the result.\n     *\n     * @return RelativePathInterface A relative path from the supplied path to\n     *     this path.\n     *\/\n    public function relativeTo(\n        AbsolutePathInterface $path,\n        PathNormalizerInterface $normalizer = null\n    ) {\n        if (null === $normalizer) {\n            $normalizer = $this->createDefaultNormalizer();\n        }\n\n        $thisDrive = $this->normalizePathDriveSpecifier($this);\n        $pathDrive = $this->normalizePathDriveSpecifier($path);\n        if ($thisDrive !== $pathDrive) {\n            throw new Exception\\DriveMismatchException(\n                $thisDrive,\n                $pathDrive\n            );\n        }\n\n        return parent::relativeTo($path, $normalizer);\n    }\n\n    \/\/ Implementation details ==================================================\n\n    \/**\n     * @param string $atom\n     *\/\n    protected function validateAtom($atom)\n    {\n        parent::validateAtom($atom);\n\n        if (false !== strpos($atom, '\\\\')) {\n            throw new PathAtomContainsSeparatorException($atom);\n        } elseif (preg_match('\/([\\x00-\\x1F<>:\"|?*])\/', $atom, $matches)) {\n            throw new InvalidPathAtomCharacterException($atom, $matches[1]);\n        }\n    }\n\n    \/**\n     * @param AbsolutePathInterface $path\n     *\n     * @return string|null\n     *\/\n    protected function normalizePathDriveSpecifier(AbsolutePathInterface $path)\n    {\n        if ($path instanceof AbsoluteWindowsPathInterface) {\n            $drive = $path->drive();\n            if (null !== $drive) {\n                $drive = strtoupper($drive);\n            }\n\n            return $drive;\n        }\n\n        return null;\n    }\n\n    \/**\n     * @param AbsolutePathInterface $left\n     * @param AbsolutePathInterface $right\n     *\n     * @return boolean\n     *\/\n    protected function driveSpecifiersMatch(\n        AbsolutePathInterface $left,\n        AbsolutePathInterface $right\n    ) {\n        $leftDrive = $this->normalizePathDriveSpecifier($left);\n        $rightDrive = $this->normalizePathDriveSpecifier($right);\n\n        return $leftDrive === $rightDrive;\n    }\n\n    \/**\n     * @param mixed<string> $atoms\n     * @param boolean       $isAbsolute\n     * @param boolean|null  $hasTrailingSeparator\n     *\n     * @return PathInterface\n     *\/\n    protected function createPath(\n        $atoms,\n        $isAbsolute,\n        $hasTrailingSeparator = null\n    ) {\n        if ($isAbsolute) {\n            return $this->createPathWithDrive(\n                $atoms,\n                $this->drive(),\n                $hasTrailingSeparator\n            );\n        }\n\n        return new RelativeWindowsPath($atoms, $hasTrailingSeparator);\n    }\n\n    \/**\n     * @param mixed<string> $atoms\n     * @param string|null   $drive\n     * @param boolean|null  $hasTrailingSeparator\n     *\n     * @return PathInterface\n     *\/\n    protected function createPathWithDrive(\n        $atoms,\n        $drive,\n        $hasTrailingSeparator = null\n    ) {\n        return new static($atoms, $drive, $hasTrailingSeparator);\n    }\n\n    private $drive;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,613,2,null,null,611,null,569,569,null,null,null,null,null,null,null,null,null,null,null,470,null,null,null,null,null,null,null,null,null,14,null,null,null,null,null,null,null,null,null,null,null,null,null,4,4,4,null,4,null,null,null,null,null,null,null,null,null,null,null,328,328,null,null,164,164,164,164,164,null,null,null,164,164,164,164,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,20,20,20,null,20,2,null,null,18,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,20,20,20,null,20,2,null,null,18,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,19,19,19,null,19,19,19,2,2,null,2,null,null,17,null,null,null,null,null,null,null,null,null,579,null,577,4,576,117,null,537,null,null,null,null,null,null,null,null,39,39,39,22,22,null,39,null,null,3,null,null,null,null,null,null,null,null,null,null,null,null,20,20,null,20,null,null,null,null,null,null,null,null,null,null,null,null,null,null,333,316,316,316,null,316,null,null,17,null,null,null,null,null,null,null,null,null,null,null,null,null,null,320,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/AbsoluteWindowsPathInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows;\n\nuse Eloquent\\Pathogen\\FileSystem\\AbsoluteFileSystemPathInterface;\n\n\/**\n * The interface implemented by absolute Windows paths.\n *\/\ninterface AbsoluteWindowsPathInterface extends\n    AbsoluteFileSystemPathInterface,\n    WindowsPathInterface\n{\n    \/**\n     * Get this path's drive specifier.\n     *\n     * @return string|null The drive specifier, or null if this path does not\n     *     have a drive specifier.\n     *\/\n    public function drive();\n\n    \/**\n     * Determine whether this path has a drive specifier.\n     *\n     * @return boolean True is this path has a drive specifier.\n     *\/\n    public function hasDrive();\n\n    \/**\n     * Joins the supplied drive specifier to this path.\n     *\n     * @return string|null $drive The drive specifier to use, or null to remove\n     *     the drive specifier.\n     *\n     * @return AbsoluteWindowsPathInterface A new path instance with the\n     *     supplied drive specifier joined to this path.\n     *\/\n    public function joinDrive($drive);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/Exception\/DriveMismatchException.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows\\Exception;\n\nuse Exception;\n\n\/**\n * The drive specifiers of the two paths do not match.\n *\/\nfinal class DriveMismatchException extends Exception\n{\n    \/**\n     * Constructs a new drive specifier mismatch exception.\n     *\n     * @param string         $leftDrive  The left-hand drive specifier.\n     * @param string         $rightDrive The right-hand drive specifier.\n     * @param Exception|null $previous   The previous exception, if available.\n     *\/\n    public function __construct(\n        $leftDrive,\n        $rightDrive,\n        Exception $previous = null\n    ) {\n        $this->leftDrive = $leftDrive;\n        $this->rightDrive = $rightDrive;\n\n        parent::__construct(\n            sprintf(\n                'Drive specifiers %s and %s do not match.',\n                var_export($leftDrive, true),\n                var_export($rightDrive, true)\n            ),\n            0,\n            $previous\n        );\n    }\n\n    \/**\n     * Get the left-hand drive specifier.\n     *\n     * @return string The left-hand drive specifier.\n     *\/\n    public function leftDrive()\n    {\n        return $this->leftDrive;\n    }\n\n    \/**\n     * Get the right-hand drive specifier.\n     *\n     * @return string The right-hand drive specifier.\n     *\/\n    public function rightDrive()\n    {\n        return $this->rightDrive;\n    }\n\n    private $leftDrive;\n    private $rightDrive;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,null,1,1,1,1,1,1,1,null,1,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/Exception\/InvalidDriveSpecifierException.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows\\Exception;\n\nuse Exception;\n\n\/**\n * The provided drive specifier is invalid.\n *\/\nfinal class InvalidDriveSpecifierException extends Exception\n{\n    \/**\n     * Constructs a new invalid drive specifier exception.\n     *\n     * @param string         $drive    The invalid drive specifier.\n     * @param Exception|null $previous The previous exception, if available.\n     *\/\n    public function __construct($drive, Exception $previous = null)\n    {\n        $this->drive = $drive;\n\n        parent::__construct(\n            sprintf('Invalid drive specifier %s.', var_export($drive, true)),\n            0,\n            $previous\n        );\n    }\n\n    \/**\n     * Get the invalid drive specifier.\n     *\n     * @return string The invalid drive specifier.\n     *\/\n    public function drive()\n    {\n        return $this->drive;\n    }\n\n    private $drive;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,1,1,null,null,null,null,null,null,null,null,1,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/Factory\/WindowsPathFactory.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows\\Factory;\n\nuse Eloquent\\Pathogen\\Exception\\InvalidPathAtomExceptionInterface;\nuse Eloquent\\Pathogen\\Exception\\InvalidPathStateException;\nuse Eloquent\\Pathogen\\Factory\\PathFactory;\nuse Eloquent\\Pathogen\\PathInterface;\nuse Eloquent\\Pathogen\\Windows\\AbsoluteWindowsPath;\nuse Eloquent\\Pathogen\\Windows\\RelativeWindowsPath;\n\n\/**\n * A path factory that creates Windows path instances.\n *\/\nclass WindowsPathFactory extends PathFactory implements\n    WindowsPathFactoryInterface\n{\n    \/**\n     * Construct a new Windows path factory.\n     *\n     * @param string $defaultDrive The default drive specifier to use when none\n     *     is specified, or null to leave the drive specifier empty.\n     *\/\n    public function __construct($defaultDrive = null)\n    {\n        $this->defaultDrive = $defaultDrive;\n    }\n\n    \/**\n     * Get the default drive specifier.\n     *\n     * @return string|null The default drive specifier.\n     *\/\n    public function defaultDrive()\n    {\n        return $this->defaultDrive;\n    }\n\n    \/\/ Implementation of PathFactoryInterface ==================================\n\n    \/**\n     * Creates a new path instance from its string representation.\n     *\n     * @param string $path The string representation of the path.\n     *\n     * @return PathInterface The newly created path instance.\n     *\/\n    public function create($path)\n    {\n        if ('' === $path) {\n            $path = PathInterface::SELF_ATOM;\n        }\n\n        $isAbsolute = false;\n        $drive = null;\n        $hasTrailingSeparator = false;\n\n        $atoms = preg_split('~[\/\\\\\\\\]~', $path);\n        if (preg_match('\/^([a-zA-Z]):$\/', $atoms[0], $matches)) {\n            $isAbsolute = true;\n            $drive = $matches[1];\n            array_shift($atoms);\n        }\n        $numAtoms = count($atoms);\n\n        if ($numAtoms > 1) {\n            if ('' === $atoms[0]) {\n                $isAbsolute = true;\n                array_shift($atoms);\n                --$numAtoms;\n            }\n\n            if ('' === $atoms[$numAtoms - 1]) {\n                $hasTrailingSeparator = !$isAbsolute || $numAtoms > 1;\n                array_pop($atoms);\n                --$numAtoms;\n            }\n        }\n\n        foreach ($atoms as $index => $atom) {\n            if ('' === $atom) {\n                array_splice($atoms, $index, 1);\n                --$numAtoms;\n            }\n        }\n\n        return $this->createFromDriveAndAtoms(\n            $atoms,\n            $drive,\n            $isAbsolute,\n            $hasTrailingSeparator\n        );\n    }\n\n    \/**\n     * Creates a new path instance from a set of path atoms.\n     *\n     * Unless otherwise specified, created paths will be absolute, and have no\n     * trailing separator.\n     *\n     * @param mixed<string> $atoms                The path atoms.\n     * @param boolean|null  $isAbsolute           True if the path is absolute.\n     * @param boolean|null  $hasTrailingSeparator True if the path has a\n     *     trailing separator.\n     *\n     * @return PathInterface                     The newly created path instance.\n     * @throws InvalidPathAtomExceptionInterface If any of the supplied atoms\n     *     are invalid.\n     *\/\n    public function createFromAtoms(\n        $atoms,\n        $isAbsolute = null,\n        $hasTrailingSeparator = null\n    ) {\n        return $this->createFromDriveAndAtoms(\n            $atoms,\n            $isAbsolute ? $this->defaultDrive() : null,\n            $isAbsolute,\n            $hasTrailingSeparator\n        );\n    }\n\n    \/\/ Implementation of WindowsPathFactoryInterface ===========================\n\n    \/**\n     * Creates a new path instance from a set of path atoms and a drive\n     * specifier.\n     *\n     * Unless otherwise specified, created paths will be absolute, and have no\n     * trailing separator.\n     *\n     * @param mixed<string> $atoms                The path atoms.\n     * @param string|null   $drive                The drive specifier.\n     * @param boolean|null  $isAbsolute           True if the path is absolute.\n     * @param boolean|null  $hasTrailingSeparator True if the path has a\n     *     trailing separator.\n     *\n     * @return PathInterface                     The newly created path instance.\n     * @throws InvalidPathAtomExceptionInterface If any of the supplied atoms\n     *     are invalid.\n     *\/\n    public function createFromDriveAndAtoms(\n        $atoms,\n        $drive,\n        $isAbsolute = null,\n        $hasTrailingSeparator = null\n    ) {\n        if (!$isAbsolute && null !== $drive) {\n            throw new InvalidPathStateException(\n                \"Path cannot be relative and have a drive specifier.\"\n            );\n        }\n\n        if ($isAbsolute) {\n            return new AbsoluteWindowsPath(\n                $atoms,\n                $drive,\n                $hasTrailingSeparator\n            );\n        }\n\n        return new RelativeWindowsPath($atoms, $hasTrailingSeparator);\n    }\n\n    private $defaultDrive;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,82,82,null,null,null,null,null,null,null,null,19,null,null,null,null,null,null,null,null,null,null,null,null,null,25,1,1,null,25,25,25,null,25,25,9,9,9,9,25,null,25,21,9,9,9,9,null,21,10,10,10,10,21,null,25,23,8,8,8,25,null,25,25,25,25,null,25,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,25,25,25,25,null,25,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,76,1,null,1,null,null,75,51,51,51,null,51,null,null,24,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/Factory\/WindowsPathFactoryInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows\\Factory;\n\nuse Eloquent\\Pathogen\\Exception\\InvalidPathAtomExceptionInterface;\nuse Eloquent\\Pathogen\\Factory\\PathFactoryInterface;\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * The interface implemented by path factories that create Windows paths.\n *\/\ninterface WindowsPathFactoryInterface extends PathFactoryInterface\n{\n    \/**\n     * Creates a new path instance from a set of path atoms and a drive\n     * specifier.\n     *\n     * Unless otherwise specified, created paths will be absolute, and have no\n     * trailing separator.\n     *\n     * @param mixed<string> $atoms                The path atoms.\n     * @param string|null   $drive                The drive specifier.\n     * @param boolean|null  $isAbsolute           True if the path is absolute.\n     * @param boolean|null  $hasTrailingSeparator True if the path has a\n     *     trailing separator.\n     *\n     * @return PathInterface                     The newly created path instance.\n     * @throws InvalidPathAtomExceptionInterface If any of the supplied atoms\n     *     are invalid.\n     *\/\n    public function createFromDriveAndAtoms(\n        $atoms,\n        $drive,\n        $isAbsolute = null,\n        $hasTrailingSeparator = null\n    );\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/Normalizer\/WindowsPathNormalizer.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows\\Normalizer;\n\nuse Eloquent\\Pathogen\\PathInterface;\nuse Eloquent\\Pathogen\\Normalizer\\PathNormalizer;\nuse Eloquent\\Pathogen\\Windows\\AbsoluteWindowsPathInterface;\nuse Eloquent\\Pathogen\\Windows\\Factory\\WindowsPathFactory;\nuse Eloquent\\Pathogen\\Windows\\Factory\\WindowsPathFactoryInterface;\n\n\/**\n * A path normalizer suitable for normalizing Windows paths.\n *\/\nclass WindowsPathNormalizer extends PathNormalizer\n{\n    \/**\n     * Construct a new Windows path normalizer.\n     *\n     * @param WindowsPathFactoryInterface|null $factory The path factory to use.\n     *\/\n    public function __construct(WindowsPathFactoryInterface $factory = null)\n    {\n        if (null === $factory) {\n            $factory = new WindowsPathFactory;\n        }\n\n        parent::__construct($factory);\n    }\n\n    \/**\n     * Normalize the supplied path to its most canonical form.\n     *\n     * @param PathInterface $path The path to normalize.\n     *\n     * @return PathInterface The normalized path.\n     *\/\n    public function normalize(PathInterface $path)\n    {\n        if ($path instanceof AbsoluteWindowsPathInterface) {\n            return $this->normalizeAbsoluteWindowsPath($path);\n        }\n\n        return parent::normalize($path);\n    }\n\n    \/**\n     * @param AbsoluteWindowsPathInterface $path\n     *\n     * @return AbsoluteWindowsPathInterface\n     *\/\n    protected function normalizeAbsoluteWindowsPath(\n        AbsoluteWindowsPathInterface $path\n    ) {\n        return $this->factory()->createFromDriveAndAtoms(\n            $this->normalizeAbsolutePathAtoms($path->atoms()),\n            $this->normalizeDriveSpecifier($path->drive()),\n            true,\n            false\n        );\n    }\n\n    \/**\n     * @param string|null $drive\n     *\n     * @return string|null\n     *\/\n    protected function normalizeDriveSpecifier($drive)\n    {\n        if (null === $drive) {\n            return null;\n        }\n\n        return strtoupper($drive);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,66,66,66,null,66,66,null,null,null,null,null,null,null,null,null,null,66,35,null,null,31,null,null,null,null,null,null,null,null,null,null,35,35,35,35,null,35,null,null,null,null,null,null,null,null,null,35,17,null,null,18,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/RelativeWindowsPath.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows;\n\nuse Eloquent\\Pathogen\\Exception\\InvalidPathAtomCharacterException;\nuse Eloquent\\Pathogen\\Exception\\PathAtomContainsSeparatorException;\nuse Eloquent\\Pathogen\\FileSystem\\AbstractRelativeFileSystemPath;\n\n\/**\n * Represents a relative Windows path.\n *\/\nclass RelativeWindowsPath extends AbstractRelativeFileSystemPath implements\n    RelativeWindowsPathInterface\n{\n    \/**\n     * @param string $atom\n     *\/\n    protected function validateAtom($atom)\n    {\n        parent::validateAtom($atom);\n\n        if (false !== strpos($atom, '\\\\')) {\n            throw new PathAtomContainsSeparatorException($atom);\n        } elseif (preg_match('\/([\\x00-\\x1F<>:\"|?*])\/', $atom, $matches)) {\n            throw new InvalidPathAtomCharacterException($atom, $matches[1]);\n        }\n    }\n\n    \/**\n     * @param mixed<string> $atoms\n     * @param boolean       $isAbsolute\n     * @param boolean|null  $hasTrailingSeparator\n     *\n     * @return PathInterface\n     *\/\n    protected function createPath(\n        $atoms,\n        $isAbsolute,\n        $hasTrailingSeparator = null\n    ) {\n        return new static($atoms, $hasTrailingSeparator);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,371,null,369,3,368,117,null,329,null,null,null,null,null,null,null,null,null,null,null,null,null,193,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/RelativeWindowsPathInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows;\n\nuse Eloquent\\Pathogen\\FileSystem\\RelativeFileSystemPathInterface;\n\n\/**\n * The interface implemented by relative Windows paths.\n *\/\ninterface RelativeWindowsPathInterface extends\n    RelativeFileSystemPathInterface,\n    WindowsPathInterface\n{\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/WindowsPathInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows;\n\nuse Eloquent\\Pathogen\\FileSystem\\FileSystemPathInterface;\n\n\/**\n * The interface implemented by all Windows paths.\n *\/\ninterface WindowsPathInterface extends FileSystemPathInterface\n{\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}]}