{"service_name":"travis-ci","service_job_id":"8845923","git":{"branch":"(detached from 82db42b)","head":{"id":"82db42b60c6b6cf549fe1de81495d6bbd044ad68","author_name":"Erin Millard","author_email":"ezzatron@gmail.com","committer_name":"Erin Millard","committer_email":"ezzatron@gmail.com","message":"Updating Archer."},"remotes":[{"name":"origin","url":"git:\/\/github.com\/eloquent\/pathogen.git"}]},"run_at":"2013-07-08 12:33:19 +0000","source_files":[{"name":"Eloquent\/Pathogen\/AbsolutePath.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen;\n\n\/**\n * Represents an absolute path.\n *\/\nclass AbsolutePath extends AbstractPath implements AbsolutePathInterface\n{\n    \/\/ Implementation of PathInterface =========================================\n\n    \/**\n     * Generate a string representation of this path.\n     *\n     * @return string A string representation of this path.\n     *\/\n    public function string()\n    {\n        return static::ATOM_SEPARATOR . parent::string();\n    }\n\n    \/**\n     * Adds a trailing slash to this path.\n     *\n     * @return PathInterface A new path instance with a trailing slash suffixed\n     *     to this path.\n     *\/\n    public function joinTrailingSlash()\n    {\n        if (!$this->hasAtoms()) {\n            return $this;\n        }\n\n        return parent::joinTrailingSlash();\n    }\n\n    \/\/ Implementation of AbsolutePathInterface =================================\n\n    \/**\n     * Determine whether this path is the root path.\n     *\n     * The root path is an absolute path with no atoms.\n     *\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return boolean True if this path is the root path.\n     *\/\n    public function isRoot(\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    ) {\n        if (null == $normalizer) {\n            $normalizer = new Normalizer\\PathNormalizer;\n        }\n\n        return !$normalizer->normalize($this)->hasAtoms();\n    }\n\n    \/**\n     * Determine if this path is the direct parent of the supplied path.\n     *\n     * @param AbsolutePathInterface                   $path       The child path.\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return boolean True if this path is the direct parent of the supplied\n     *     path.\n     *\/\n    public function isParentOf(\n        AbsolutePathInterface $path,\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    ) {\n        if (null == $normalizer) {\n            $normalizer = new Normalizer\\PathNormalizer;\n        }\n\n        return\n            $path->hasAtoms() &&\n            $normalizer->normalize($this)->atoms() ===\n                $normalizer->normalize($path->parent())->atoms();\n    }\n\n    \/**\n     * Determine if this path is an ancestor of the supplied path.\n     *\n     * @param AbsolutePathInterface                   $path       The child path.\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return boolean True if this path is an ancestor of the supplied path.\n     *\/\n    public function isAncestorOf(\n        AbsolutePathInterface $path,\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    ) {\n        if (null == $normalizer) {\n            $normalizer = new Normalizer\\PathNormalizer;\n        }\n\n        $parentAtoms = $normalizer->normalize($this)->atoms();\n\n        return $parentAtoms === array_slice(\n            $normalizer->normalize($path)->atoms(),\n            0,\n            count($parentAtoms)\n        );\n    }\n\n    \/**\n     * Determine the shortest path from the supplied path to this path.\n     *\n     * For example, given path A equal to '\/foo\/bar', and path B equal to\n     * '\/foo\/baz', A relative to B would be '..\/bar'.\n     *\n     * @param AbsolutePathInterface $path The path that the generated path will\n     *     be relative to.\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return RelativePathInterface A relative path from the supplied path to\n     *     this path.\n     *\/\n    public function relativeTo(\n        AbsolutePathInterface $path,\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    ) {\n        if (null == $normalizer) {\n            $normalizer = new Normalizer\\PathNormalizer;\n        }\n\n        $parentAtoms = $normalizer->normalize($path)->atoms();\n        $childAtoms = $normalizer->normalize($this)->atoms();\n\n        if ($childAtoms === $parentAtoms) {\n            $diffAtoms = array(static::SELF_ATOM);\n        } else {\n            $diffAtoms = array_diff_assoc($childAtoms, $parentAtoms);\n            $fillCount =\n                (count($parentAtoms) - count($childAtoms)) +\n                count($diffAtoms);\n\n            if ($fillCount > 0) {\n                $diffAtoms = array_merge(\n                    array_fill(0, $fillCount, static::PARENT_ATOM),\n                    $diffAtoms\n                );\n            }\n        }\n\n        return $this->createPath($diffAtoms, false);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,120,null,null,null,null,null,null,null,null,null,null,15,3,null,null,12,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,9,9,9,null,9,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,26,8,8,null,null,26,26,26,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,27,9,9,null,27,null,27,27,27,27,27,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,26,9,9,null,26,26,null,26,3,3,23,null,23,23,null,23,15,15,null,15,15,null,null,26,null,null]},{"name":"Eloquent\/Pathogen\/AbsolutePathInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen;\n\n\/**\n * The interface implemented by absolute paths.\n *\/\ninterface AbsolutePathInterface extends PathInterface\n{\n    \/**\n     * Determine whether this path is the root path.\n     *\n     * The root path is an absolute path with no atoms.\n     *\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return boolean True if this path is the root path.\n     *\/\n    public function isRoot(\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    );\n\n    \/**\n     * Determine if this path is the direct parent of the supplied path.\n     *\n     * @param AbsolutePathInterface                   $path       The child path.\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return boolean True if this path is the direct parent of the supplied\n     *     path.\n     *\/\n    public function isParentOf(\n        AbsolutePathInterface $path,\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    );\n\n    \/**\n     * Determine if this path is an ancestor of the supplied path.\n     *\n     * @param AbsolutePathInterface                   $path       The child path.\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return boolean True if this path is an ancestor of the supplied path.\n     *\/\n    public function isAncestorOf(\n        AbsolutePathInterface $path,\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    );\n\n    \/**\n     * Determine the shortest path from the supplied path to this path.\n     *\n     * For example, given path A equal to '\/foo\/bar', and path B equal to\n     * '\/foo\/baz', A relative to B would be '..\/bar'.\n     *\n     * @param AbsolutePathInterface $path The path that the generated path will\n     *     be relative to.\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return RelativePathInterface A relative path from the supplied path to\n     *     this path.\n     *\/\n    public function relativeTo(\n        AbsolutePathInterface $path,\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    );\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/AbstractPath.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen;\n\n\/**\n * Abstract base class for implementing PathInterface.\n *\/\nabstract class AbstractPath implements PathInterface\n{\n    \/**\n     * Construct a new path instance.\n     *\n     * @param mixed<string> $atoms                The path atoms.\n     * @param boolean|null  $hasTrailingSeparator True if this path has a\n     *     trailing separator.\n     *\n     * @throws Exception\\InvalidPathAtomExceptionInterface If any of the\n     *     supplied path atoms are invalid.\n     *\/\n    public function __construct($atoms, $hasTrailingSeparator = null)\n    {\n        if (null === $hasTrailingSeparator) {\n            $hasTrailingSeparator = false;\n        }\n\n        $this->atoms = $this->normalizeAtoms($atoms);\n        $this->hasTrailingSeparator = $hasTrailingSeparator === true;\n    }\n\n    \/\/ Implementation of PathInterface =========================================\n\n    \/**\n     * Get the atoms of this path.\n     *\n     * For example, the path '\/foo\/bar' has the atoms 'foo' and 'bar'.\n     *\n     * @return array<integer,string> The atoms of this path as an array of\n     * strings.\n     *\/\n    public function atoms()\n    {\n        return $this->atoms;\n    }\n\n    \/**\n     * Get a subset of the atoms of this path.\n     *\n     * @param integer      $index  The index of the first atom.\n     * @param integer|null $length The maximum number of atoms.\n     *\n     * @return array<integer,string> An array of strings representing the subset\n     *     of path atoms.\n     *\/\n    public function sliceAtoms($index, $length = null)\n    {\n        $atoms = $this->atoms();\n        if (null === $length) {\n            $length = count($atoms);\n        }\n\n        return array_slice($atoms, $index, $length);\n    }\n\n    \/**\n     * Determine if this path has any atoms.\n     *\n     * @return boolean True if this path has at least one atom.\n     *\/\n    public function hasAtoms()\n    {\n        return count($this->atoms()) > 0;\n    }\n\n    \/**\n     * Determine if this path has a trailing separator.\n     *\n     * @return boolean True if this path has a trailing separator.\n     *\/\n    public function hasTrailingSeparator()\n    {\n        return $this->hasTrailingSeparator;\n    }\n\n    \/**\n     * Generate a string representation of this path.\n     *\n     * @return string A string representation of this path.\n     *\/\n    public function string()\n    {\n        return\n            implode(static::ATOM_SEPARATOR, $this->atoms()) .\n            ($this->hasTrailingSeparator() ? static::ATOM_SEPARATOR : '')\n        ;\n    }\n\n    \/**\n     * Generate a string representation of this path.\n     *\n     * @return string A string representation of this path.\n     *\/\n    public function __toString()\n    {\n        return $this->string();\n    }\n\n    \/**\n     * Get this path's name.\n     *\n     * @return string The last path atom if one exists, otherwise an empty\n     *     string.\n     *\/\n    public function name()\n    {\n        $atoms = $this->atoms();\n        $numAtoms = count($atoms);\n\n        if ($numAtoms > 0) {\n            return $atoms[$numAtoms - 1];\n        }\n\n        return '';\n    }\n\n    \/**\n     * Get this path's name atoms.\n     *\n     * For example, the path name 'foo.bar' has the atoms 'foo' and 'bar'.\n     *\n     * @return array<integer,string> The atoms of this path's name as an array\n     *     of strings.\n     *\/\n    public function nameAtoms()\n    {\n        return explode(static::EXTENSION_SEPARATOR, $this->name());\n    }\n\n    \/**\n     * Get a subset of this path's name atoms.\n     *\n     * @param integer      $index  The index of the first atom.\n     * @param integer|null $length The maximum number of atoms.\n     *\n     * @return array<integer,string> An array of strings representing the subset\n     *     of path name atoms.\n     *\/\n    public function sliceNameAtoms($index, $length = null)\n    {\n        $atoms = $this->nameAtoms();\n        if (null === $length) {\n            $length = count($atoms);\n        }\n\n        return array_slice($atoms, $index, $length);\n    }\n\n    \/**\n     * Get this path's name, excluding the last extension.\n     *\n     * @return string The last atom of this path, excluding the last extension.\n     *     If this path has no atoms, an empty string is returned.\n     *\/\n    public function nameWithoutExtension()\n    {\n        $atoms = $this->nameAtoms();\n        if (count($atoms) > 1) {\n            array_pop($atoms);\n\n            return implode(static::EXTENSION_SEPARATOR, $atoms);\n        }\n\n        return $atoms[0];\n    }\n\n    \/**\n     * Get this path's name, excluding all extensions.\n     *\n     * @return string The last atom of this path, excluding any extensions. If\n     *     this path has no atoms, an empty string is returned.\n     *\/\n    public function namePrefix()\n    {\n        $atoms = $this->nameAtoms();\n\n        return $atoms[0];\n    }\n\n    \/**\n     * Get all of this path's extensions.\n     *\n     * @return string|null The extensions of this path's last atom. If the last\n     *     atom has no extensions, or this path has no atoms, this method will\n     *     return null.\n     *\/\n    public function nameSuffix()\n    {\n        $atoms = $this->nameAtoms();\n        if (count($atoms) > 1) {\n            array_shift($atoms);\n\n            return implode(static::EXTENSION_SEPARATOR, $atoms);\n        }\n\n        return null;\n    }\n\n    \/**\n     * Get this path's last extension.\n     *\n     * @return string|null The last extension of this path's last atom. If the\n     *     last atom has no extensions, or this path has no atoms, this method\n     *     will return null.\n     *\/\n    public function extension()\n    {\n        $atoms = $this->nameAtoms();\n        $numParts = count($atoms);\n\n        if ($numParts > 1) {\n            return $atoms[$numParts - 1];\n        }\n\n        return null;\n    }\n\n    \/**\n     * Determine if this path has any extensions.\n     *\n     * @return boolean True if this path's last atom has any extensions.\n     *\/\n    public function hasExtension()\n    {\n        return count($this->nameAtoms()) > 1;\n    }\n\n    \/**\n     * Get the parent of this path a specified number of levels up.\n     *\n     * @param integer|null $numLevels The number of levels up. Defaults to 1.\n     *\n     * @return PathInterface The parent of this path $numLevels up.\n     *\/\n    public function parent($numLevels = null)\n    {\n        if (null === $numLevels) {\n            $numLevels = 1;\n        }\n\n        $atoms = array_merge(\n            $this->atoms(),\n            array_fill(0, $numLevels, static::PARENT_ATOM)\n        );\n\n        return $this->createPath(\n            $atoms,\n            $this instanceof AbsolutePathInterface\n        );\n    }\n\n    \/**\n     * Strips the trailing slash from this path.\n     *\n     * @return PathInterface A new path instance with the trailing slash removed\n     *     from this path. If this path has no trailing slash, the path is\n     *     returned unmodified.\n     *\/\n    public function stripTrailingSlash()\n    {\n        if (!$this->hasTrailingSeparator()) {\n            return $this;\n        }\n\n        return $this->createPath(\n            $this->atoms(),\n            $this instanceof AbsolutePathInterface\n        );\n    }\n\n    \/**\n     * Strips the last extension from this path.\n     *\n     * @return PathInterface A new path instance with the last extension removed\n     *     from this path. If this path has no extensions, the path is returned\n     *     unmodified.\n     *\/\n    public function stripExtension()\n    {\n        return $this->replaceExtension(null);\n    }\n\n    \/**\n     * Strips all extensions from this path.\n     *\n     * @return PathInterface A new path instance with all extensions removed\n     *     from this path. If this path has no extensions, the path is returned\n     *     unmodified.\n     *\/\n    public function stripNameSuffix()\n    {\n        return $this->replaceNameSuffix(null);\n    }\n\n    \/**\n     * Joins one or more atoms to this path.\n     *\n     * @param string     $atom            A path atom to append.\n     * @param string,... $additionalAtoms Additional path atoms to append.\n     *\n     * @return PathInterface A new path with the supplied atom(s) suffixed to\n     *     this path.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If any joined atoms\n     *     are invalid.\n     *\/\n    public function joinAtoms($atom)\n    {\n        return $this->joinAtomSequence(func_get_args());\n    }\n\n    \/**\n     * Joins a sequence of atoms to this path.\n     *\n     * @param mixed<string> $atoms The path atoms to append.\n     *\n     * @return PathInterface A new path with the supplied sequence of atoms\n     *     suffixed to this path.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If any joined atoms\n     *     are invalid.\n     *\/\n    public function joinAtomSequence($atoms)\n    {\n        if (!is_array($atoms)) {\n            $atoms = iterator_to_array($atoms);\n        }\n\n        return $this->createPath(\n            array_merge($this->atoms(), $atoms),\n            $this instanceof AbsolutePathInterface\n        );\n    }\n\n    \/**\n     * Joins the supplied path to this path.\n     *\n     * @param RelativePathInterface $path The path whose atoms should be joined\n     *     to this path.\n     *\n     * @return PathInterface A new path with the supplied path suffixed to this\n     *     path.\n     *\/\n    public function join(RelativePathInterface $path)\n    {\n        return $this->joinAtomSequence($path->atoms());\n    }\n\n    \/**\n     * Returns a new path instance with a trailing slash suffixed to this path.\n     *\n     * @return PathInterface\n     *\/\n    public function joinTrailingSlash()\n    {\n        if ($this->hasTrailingSeparator()) {\n            return $this;\n        }\n\n        return $this->createPath(\n            $this->atoms(),\n            $this instanceof AbsolutePathInterface,\n            true\n        );\n    }\n\n    \/**\n     * Joins one or more extensions to this path.\n     *\n     * @param string     $extension            An extension to append.\n     * @param string,... $additionalExtensions Additional extensions to append.\n     *\n     * @return PathInterface A new path instance with the supplied extensions\n     *     suffixed to this path.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If the suffixed\n     *     extensions cause the atom to be invalid.\n     *\/\n    public function joinExtensions($extension)\n    {\n        return $this->joinExtensionSequence(func_get_args());\n    }\n\n    \/**\n     * Joins a sequence of extensions to this path.\n     *\n     * @param mixed<string> $extensions\n     *\n     * @return PathInterface A new path instance with the supplied extensions\n     *     suffixed to this path.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If the suffixed\n     *     extensions cause the atom to be invalid.\n     *\/\n    public function joinExtensionSequence($extensions)\n    {\n        if (!is_array($extensions)) {\n            $extensions = iterator_to_array($extensions);\n        }\n\n        $atoms = $this->nameAtoms();\n        if (array('', '') === $atoms) {\n            array_pop($atoms);\n        }\n\n        return $this->replaceName(\n            implode(\n                static::EXTENSION_SEPARATOR,\n                array_merge($atoms, $extensions)\n            )\n        );\n    }\n\n    \/**\n     * Suffixes this path's name with a supplied string.\n     *\n     * @param string $suffix The string to suffix to the path name.\n     *\n     * @return PathInterface A new path instance with the supplied string\n     *     suffixed to the last path atom.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If the suffix causes\n     *     the atom to be invalid.\n     *\/\n    public function suffixName($suffix)\n    {\n        $name = $this->name();\n        if (static::SELF_ATOM === $name) {\n            return $this->replaceName($suffix);\n        }\n\n        return $this->replaceName($name . $suffix);\n    }\n\n    \/**\n     * Prefixes this path's name with a supplied string.\n     *\n     * @param string $prefix The string to prefix to the path name.\n     *\n     * @return PathInterface A new path instance with the supplied string\n     *     prefixed to the last path atom.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If the prefix causes\n     *     the atom to be invalid.\n     *\/\n    public function prefixName($prefix)\n    {\n        $name = $this->name();\n        if (static::SELF_ATOM === $name) {\n            return $this->replaceName($prefix);\n        }\n\n        return $this->replaceName($prefix . $name);\n    }\n\n    \/**\n     * Replace a section of this path with the supplied atom sequence.\n     *\n     * @param integer       $index       The start index of the replacement.\n     * @param mixed<string> $replacement The replacement atom sequence.\n     * @param integer|null  $length      The number of atoms to replace. If\n     *     $length is null, the entire remainder of the path will be replaced.\n     *\n     * @return PathInterface A new path instance that has a portion of this\n     *     path's atoms replaced with a different sequence of atoms.\n     *\/\n    public function replace($index, $replacement, $length = null)\n    {\n        $atoms = $this->atoms();\n\n        if (!is_array($replacement)) {\n            $replacement = iterator_to_array($replacement);\n        }\n        if (null === $length) {\n            $length = count($atoms);\n        }\n\n        array_splice($atoms, $index, $length, $replacement);\n\n        return $this->createPath(\n            $atoms,\n            $this instanceof AbsolutePathInterface\n        );\n    }\n\n    \/**\n     * Replace this path's name.\n     *\n     * @param string $name The new path name.\n     *\n     * @return PathInterface A new path instance with the supplied name\n     *     replacing the existing one.\n     *\/\n    public function replaceName($name)\n    {\n        $atoms = $this->atoms();\n        $numAtoms = count($atoms);\n\n        if ($numAtoms > 0) {\n            if ('' === $name) {\n                array_pop($atoms);\n            } else {\n                $atoms[$numAtoms - 1] = $name;\n            }\n        } elseif ('' !== $name) {\n            $atoms[] = $name;\n        }\n\n        return $this->createPath(\n            $atoms,\n            $this instanceof AbsolutePathInterface\n        );\n    }\n\n    \/**\n     * Replace this path's name, but keep the last extension.\n     *\n     * @param string $nameWithoutExtension The replacement string.\n     *\n     * @return PathInterface A new path instance with the supplied name\n     *     replacing the portion of the existing name preceding the last\n     *     extension.\n     *\/\n    public function replaceNameWithoutExtension($nameWithoutExtension)\n    {\n        $atoms = $this->nameAtoms();\n        if (count($atoms) < 2) {\n            return $this->replaceName($nameWithoutExtension);\n        }\n\n        array_splice($atoms, 0, -1, array($nameWithoutExtension));\n\n        return $this->replaceName(implode(self::EXTENSION_SEPARATOR, $atoms));\n    }\n\n    \/**\n     * Replace this path's name, but keep any extensions.\n     *\n     * @param string $namePrefix The replacement string.\n     *\n     * @return PathInterface A new path instance with the supplied name prefix\n     *     replacing the existing one.\n     *\/\n    public function replaceNamePrefix($namePrefix)\n    {\n        return $this->replaceNameAtoms(0, array($namePrefix), 1);\n    }\n\n    \/**\n     * Replace all of this path's extensions.\n     *\n     * @param string|null $nameSuffix The replacement string, or null to remove\n     *     all extensions.\n     *\n     * @return PathInterface A new path instance with the supplied name suffix\n     *     replacing the existing one.\n     *\/\n    public function replaceNameSuffix($nameSuffix)\n    {\n        $atoms = $this->nameAtoms();\n        if (array('', '') === $atoms) {\n            if (null === $nameSuffix) {\n                return $this;\n            }\n\n            return $this->replaceName(\n                static::EXTENSION_SEPARATOR . $nameSuffix\n            );\n        }\n\n        $numAtoms = count($atoms);\n\n        if (null === $nameSuffix) {\n            $replacement = array();\n        } else {\n            $replacement = array($nameSuffix);\n        }\n        array_splice($atoms, 1, count($atoms), $replacement);\n\n        return $this->replaceName(implode(self::EXTENSION_SEPARATOR, $atoms));\n    }\n\n    \/**\n     * Replace this path's last extension.\n     *\n     * @param string|null $extension The replacement string, or null to remove\n     *     the last extension.\n     *\n     * @return PathInterface A new path instance with the supplied extension\n     *     replacing the existing one.\n     *\/\n    public function replaceExtension($extension)\n    {\n        $atoms = $this->nameAtoms();\n        if (array('', '') === $atoms) {\n            if (null === $extension) {\n                return $this;\n            }\n\n            return $this->replaceName(\n                static::EXTENSION_SEPARATOR . $extension\n            );\n        }\n\n        $numAtoms = count($atoms);\n\n        if ($numAtoms > 1) {\n            if (null === $extension) {\n                $replacement = array();\n            } else {\n                $replacement = array($extension);\n            }\n\n            array_splice($atoms, -1, $numAtoms, $replacement);\n        } elseif (null !== $extension) {\n            $atoms[] = $extension;\n        }\n\n        return $this->replaceName(implode(self::EXTENSION_SEPARATOR, $atoms));\n    }\n\n    \/**\n     * Replace a section of this path's name with the supplied name atom\n     * sequence.\n     *\n     * @param integer       $index       The start index of the replacement.\n     * @param mixed<string> $replacement The replacement name atom sequence.\n     * @param integer|null  $length      The number of atoms to replace. If\n     *     $length is null, the entire remainder of the path name will be\n     *     replaced.\n     *\n     * @return PathInterface A new path instance that has a portion of this\n     *     name's atoms replaced with a different sequence of atoms.\n     *\/\n    public function replaceNameAtoms($index, $replacement, $length = null)\n    {\n        $atoms = $this->nameAtoms();\n\n        if (!is_array($replacement)) {\n            $replacement = iterator_to_array($replacement);\n        }\n        if (null === $length) {\n            $length = count($atoms);\n        }\n\n        array_splice($atoms, $index, $length, $replacement);\n\n        return $this->replaceName(implode(self::EXTENSION_SEPARATOR, $atoms));\n    }\n\n    \/\/ Implementation details ==================================================\n\n    \/**\n     * @param mixed<string> $atoms\n     *\n     * @return array<string>\n     *\/\n    protected function normalizeAtoms($atoms)\n    {\n        $normalizedAtoms = array();\n        foreach ($atoms as $atom) {\n            $this->validateAtom($atom);\n            $normalizedAtoms[] = $atom;\n        }\n\n        return $normalizedAtoms;\n    }\n\n    \/**\n     * @param string $atom\n     *\/\n    protected function validateAtom($atom)\n    {\n        if ('' === $atom) {\n            throw new Exception\\EmptyPathAtomException;\n        } elseif (false !== strpos($atom, static::ATOM_SEPARATOR)) {\n            throw new Exception\\PathAtomContainsSeparatorException($atom);\n        }\n    }\n\n    \/**\n     * @param mixed<string> $atoms\n     * @param boolean       $isAbsolute\n     * @param boolean|null  $hasTrailingSeparator\n     *\n     * @return PathInterface\n     *\/\n    protected function createPath(\n        $atoms,\n        $isAbsolute,\n        $hasTrailingSeparator = null\n    ) {\n        if ($isAbsolute) {\n            return new AbsolutePath(\n                $atoms,\n                $hasTrailingSeparator\n            );\n        }\n\n        return new RelativePath(\n            $atoms,\n            $hasTrailingSeparator\n        );\n    }\n\n    private $atoms;\n    private $hasTrailingSeparator;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1057,867,867,null,1057,967,967,null,null,null,null,null,null,null,null,null,null,null,null,null,950,null,null,null,null,null,null,null,null,null,null,null,null,null,10,10,5,5,null,10,null,null,null,null,null,null,null,null,null,50,null,null,null,null,null,null,null,null,null,610,null,null,null,null,null,null,null,null,null,null,372,372,372,null,null,null,null,null,null,null,null,null,7,null,null,null,null,null,null,null,null,null,null,429,429,null,429,396,null,null,33,null,null,null,null,null,null,null,null,null,null,null,null,351,null,null,null,null,null,null,null,null,null,null,null,null,null,10,10,5,5,null,10,null,null,null,null,null,null,null,null,null,null,40,40,32,null,32,null,null,8,null,null,null,null,null,null,null,null,null,null,40,null,40,null,null,null,null,null,null,null,null,null,null,null,40,40,32,null,32,null,null,8,null,null,null,null,null,null,null,null,null,null,null,40,40,null,40,32,null,null,8,null,null,null,null,null,null,null,null,null,40,null,null,null,null,null,null,null,null,null,null,null,51,41,41,null,51,51,51,51,null,51,51,null,51,null,null,null,null,null,null,null,null,null,null,null,25,10,null,null,15,15,null,15,null,null,null,null,null,null,null,null,null,null,null,30,null,null,null,null,null,null,null,null,null,null,null,30,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,113,null,null,null,null,null,null,null,null,null,null,null,null,null,null,258,3,3,null,258,258,null,258,null,null,null,null,null,null,null,null,null,null,null,null,null,29,null,null,null,null,null,null,null,null,null,22,5,null,null,17,17,17,null,17,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,40,null,null,null,null,null,null,null,null,null,null,null,null,null,null,82,3,3,null,82,82,4,4,null,82,82,82,82,82,82,null,null,null,null,null,null,null,null,null,null,null,null,null,null,39,39,2,null,null,37,null,null,null,null,null,null,null,null,null,null,null,null,null,null,39,39,4,null,null,35,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,35,null,35,4,4,35,15,15,null,35,null,35,35,null,35,null,null,null,null,null,null,null,null,null,null,null,null,388,388,null,388,358,30,30,328,null,388,27,27,null,388,388,null,388,null,null,null,null,null,null,null,null,null,null,null,null,null,34,34,18,null,null,16,null,16,null,null,null,null,null,null,null,null,null,null,null,null,34,null,null,null,null,null,null,null,null,null,null,null,null,null,64,64,4,2,null,null,2,2,2,null,null,60,null,60,28,28,32,null,60,null,60,null,null,null,null,null,null,null,null,null,null,null,null,null,65,65,4,2,null,null,2,2,2,null,null,61,null,61,35,20,20,15,null,null,35,61,18,18,null,61,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,63,null,63,4,4,63,10,10,null,63,null,63,null,null,null,null,null,null,null,null,null,null,null,1057,1057,1031,943,969,null,969,null,null,null,null,null,null,null,1031,12,1027,52,null,1023,null,null,null,null,null,null,null,null,null,null,null,null,null,260,136,136,null,136,null,null,124,124,null,124,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Exception\/AbstractInvalidPathAtomException.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Exception;\n\nuse Exception;\n\n\/**\n * Abstract base class for exceptions implementing\n * InvalidPathAtomExceptionInterface.\n *\/\nabstract class AbstractInvalidPathAtomException extends Exception\n    implements InvalidPathAtomExceptionInterface\n{\n    \/**\n     * Construct a new invalid path atom exception.\n     *\n     * @param string         $atom     The invalid path atom.\n     * @param Exception|null $previous The previous exception, if available.\n     *\/\n    public function __construct($atom, Exception $previous = null)\n    {\n        $this->atom = $atom;\n\n        parent::__construct(\n            sprintf(\n                \"Invalid path atom %s. %s\",\n                var_export($atom, true),\n                $this->reason()\n            ),\n            0,\n            $previous\n        );\n    }\n\n    \/**\n     * Get the invalid path atom.\n     *\n     * @return string The invalid path atom.\n     *\/\n    public function atom()\n    {\n        return $this->atom;\n    }\n\n    \/**\n     * Get the reason message.\n     *\n     * @return string The reason message.\n     *\/\n    abstract public function reason();\n\n    private $atom;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,3,3,3,3,3,3,null,3,3,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Exception\/EmptyPathAtomException.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Exception;\n\nuse Exception;\n\n\/**\n * An empty path atom was supplied.\n *\/\nfinal class EmptyPathAtomException extends AbstractInvalidPathAtomException\n{\n    \/**\n     * Construct a new empty path atom exception.\n     *\n     * @param Exception|null $previous The previous exception, if available.\n     *\/\n    public function __construct(Exception $previous = null)\n    {\n        parent::__construct('', $previous);\n    }\n\n    \/**\n     * Get the reason message.\n     *\n     * @return string The reason message.\n     *\/\n    public function reason()\n    {\n        return 'Path atoms must not be empty strings.';\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,null,null,null,null,1,null,null]},{"name":"Eloquent\/Pathogen\/Exception\/EmptyPathException.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Exception;\n\nuse Exception;\nuse LogicException;\n\n\/**\n * No path atoms were supplied when constructing a new relative path.\n *\/\nfinal class EmptyPathException extends LogicException\n{\n    \/**\n     * Construct a new empty path exception.\n     *\n     * @param Exception|null $previous The previous exception, if available.\n     *\/\n    public function __construct(Exception $previous = null)\n    {\n        parent::__construct(\n            'Relative paths must have at least one atom.',\n            0,\n            $previous\n        );\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,1,null,1,1,null]},{"name":"Eloquent\/Pathogen\/Exception\/InvalidPathAtomCharacterException.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Exception;\n\nuse Exception;\n\n\/**\n * An invalid character was encountered in a path atom.\n *\/\nfinal class InvalidPathAtomCharacterException extends AbstractInvalidPathAtomException\n{\n    \/**\n     * Construct a new invalid path atom character exception.\n     *\n     * @param string         $atom      The invalid path atom.\n     * @param string         $character The invalid character.\n     * @param Exception|null $previous  The previous exception, if available.\n     *\/\n    public function __construct($atom, $character, Exception $previous = null)\n    {\n        $this->character = $character;\n\n        parent::__construct($atom, $previous);\n    }\n\n    \/**\n     * Get the invalid character that caused the exception.\n     *\n     * @return string The invalid character.\n     *\/\n    public function character()\n    {\n        return $this->character;\n    }\n\n    \/**\n     * Get the reason message.\n     *\n     * @return string The reason message.\n     *\/\n    public function reason()\n    {\n        return sprintf(\n            'Path atom contains invalid character %s.',\n            var_export($this->character(), true)\n        );\n    }\n\n    private $character;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,1,1,1,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Exception\/InvalidPathAtomExceptionInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Exception;\n\n\/**\n * Interface for exceptions that handle invalid path atom cases.\n *\/\ninterface InvalidPathAtomExceptionInterface\n{\n    \/**\n     * Get the invalid path atom.\n     *\n     * @return string The invalid path atom.\n     *\/\n    public function atom();\n\n    \/**\n     * Get the reason message.\n     *\n     * @return string The reason message.\n     *\/\n    public function reason();\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Exception\/InvalidPathStateException.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Exception;\n\nuse Exception;\nuse LogicException;\n\n\/**\n * An attempt was made to construct a new path in an invalid state.\n *\/\nfinal class InvalidPathStateException extends LogicException\n{\n    \/**\n     * Construct a new invalid path state exception.\n     *\n     * @param string         $reason   The reason message.\n     * @param Exception|null $previous The previous exception, if available.\n     *\/\n    public function __construct($reason, Exception $previous = null)\n    {\n        $this->reason = $reason;\n\n        parent::__construct(\n            sprintf('Invalid path state. %s', $reason),\n            0,\n            $previous\n        );\n    }\n\n    \/**\n     * Get the reason message.\n     *\n     * @return string The reason message.\n     *\/\n    public function reason()\n    {\n        return $this->reason;\n    }\n\n    private $reason;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,1,1,null,null,null,null,null,null,null,null,1,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Exception\/PathAtomContainsSeparatorException.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Exception;\n\n\/**\n * A supplied path atom contains a path separator.\n *\/\nfinal class PathAtomContainsSeparatorException\n    extends AbstractInvalidPathAtomException\n{\n    \/**\n     * Get the reason message.\n     *\n     * @return string The reason message.\n     *\/\n    public function reason()\n    {\n        return 'Path atoms must not contain separators.';\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null]},{"name":"Eloquent\/Pathogen\/Factory\/PathFactory.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Factory;\n\nuse Eloquent\\Pathogen\\AbsolutePath;\nuse Eloquent\\Pathogen\\Exception\\InvalidPathAtomExceptionInterface;\nuse Eloquent\\Pathogen\\PathInterface;\nuse Eloquent\\Pathogen\\RelativePath;\n\n\/**\n * A path factory that creates generic, Unix-style path instances.\n *\/\nclass PathFactory implements PathFactoryInterface\n{\n    \/**\n     * Creates a new path instance from its string representation.\n     *\n     * @param string $path The string representation of the path.\n     *\n     * @return PathInterface The newly created path instance.\n     *\/\n    public function create($path)\n    {\n        if ('' === $path) {\n            $path = PathInterface::SELF_ATOM;\n        }\n\n        $isAbsolute = false;\n        $hasTrailingSeparator = false;\n\n        $atoms = explode(PathInterface::ATOM_SEPARATOR, $path);\n        $numAtoms = count($atoms);\n\n        if ($numAtoms > 1) {\n            if ('' === $atoms[0]) {\n                $isAbsolute = true;\n                array_shift($atoms);\n                --$numAtoms;\n            }\n\n            if ('' === $atoms[$numAtoms - 1]) {\n                $hasTrailingSeparator = !$isAbsolute || $numAtoms > 1;\n                array_pop($atoms);\n                --$numAtoms;\n            }\n        }\n\n        foreach ($atoms as $index => $atom) {\n            if ('' === $atom) {\n                array_splice($atoms, $index, 1);\n                --$numAtoms;\n            }\n        }\n\n        return $this->createFromAtoms(\n            $atoms,\n            $isAbsolute,\n            $hasTrailingSeparator\n        );\n    }\n\n    \/**\n     * Creates a new path instance from a set of path atoms.\n     *\n     * Unless otherwise specified, created paths will be absolute, and have no\n     * trailing separator.\n     *\n     * @param mixed<string> $atoms                The path atoms.\n     * @param boolean|null  $isAbsolute           True if the path is absolute.\n     * @param boolean|null  $hasTrailingSeparator True if the path has a\n     *     trailing separator.\n     *\n     * @return PathInterface                     The newly created path instance.\n     * @throws InvalidPathAtomExceptionInterface If any of the supplied atoms\n     *     are invalid.\n     *\/\n    public function createFromAtoms(\n        $atoms,\n        $isAbsolute = null,\n        $hasTrailingSeparator = null\n    ) {\n        if ($isAbsolute) {\n            return new AbsolutePath(\n                $atoms,\n                $hasTrailingSeparator\n            );\n        }\n\n        return new RelativePath(\n            $atoms,\n            $hasTrailingSeparator\n        );\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,20,1,1,null,20,20,null,20,20,null,20,18,13,13,13,13,null,18,5,5,5,5,18,null,20,19,5,5,5,20,null,20,20,20,null,20,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,34,20,20,null,20,null,null,16,16,null,16,null,null]},{"name":"Eloquent\/Pathogen\/Factory\/PathFactoryInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Factory;\n\nuse Eloquent\\Pathogen\\Exception\\InvalidPathAtomExceptionInterface;\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * The interface implemented by path factories.\n *\/\ninterface PathFactoryInterface\n{\n    \/**\n     * Creates a new path instance from its string representation.\n     *\n     * @param string $path The string representation of the path.\n     *\n     * @return PathInterface The newly created path instance.\n     *\/\n    public function create($path);\n\n    \/**\n     * Creates a new path instance from a set of path atoms.\n     *\n     * Unless otherwise specified, created paths will be absolute, and have no\n     * trailing separator.\n     *\n     * @param mixed<string> $atoms                The path atoms.\n     * @param boolean|null  $isAbsolute           True if the path is absolute.\n     * @param boolean|null  $hasTrailingSeparator True if the path has a\n     *     trailing separator.\n     *\n     * @return PathInterface                     The newly created path instance.\n     * @throws InvalidPathAtomExceptionInterface If any of the supplied atoms\n     *     are invalid.\n     *\/\n    public function createFromAtoms(\n        $atoms,\n        $isAbsolute = null,\n        $hasTrailingSeparator = null\n    );\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/FileSystem\/Factory\/AbstractFileSystemPathFactory.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\FileSystem\\Factory;\n\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\nuse Eloquent\\Pathogen\\Factory\\PathFactory;\nuse Eloquent\\Pathogen\\Factory\\PathFactoryInterface;\nuse Eloquent\\Pathogen\\Windows\\Factory\\WindowsPathFactory;\nuse Icecave\\Isolator\\Isolator;\n\n\/**\n * Abstract base class for classes implementing FileSystemPathFactoryInterface.\n *\/\nabstract class AbstractFileSystemPathFactory implements\n    FileSystemPathFactoryInterface\n{\n    \/**\n     * Construct a new file system path factory.\n     *\n     * @param PathFactoryInterface|null $posixFactory The path factory to use\n     *     for Unix-style paths.\n     * @param PathFactoryInterface|null $windowsFactory The path factory to use\n     *     for Windows paths.\n     * @param Isolator|null $isolator The isolator to use.\n     *\/\n    public function __construct(\n        PathFactoryInterface $posixFactory = null,\n        PathFactoryInterface $windowsFactory = null,\n        Isolator $isolator = null\n    ) {\n        if (null === $posixFactory) {\n            $posixFactory = new PathFactory;\n        }\n        if (null === $windowsFactory) {\n            $windowsFactory = new WindowsPathFactory;\n        }\n\n        $this->posixFactory = $posixFactory;\n        $this->windowsFactory = $windowsFactory;\n        $this->isolator = Isolator::get($isolator);\n    }\n\n    \/**\n     * Get the path factory used for Unix-style paths.\n     *\n     * @return PathFactoryInterface The path factory used for Unix-style paths.\n     *\/\n    public function posixFactory()\n    {\n        return $this->posixFactory;\n    }\n\n    \/**\n     * Get the path factory used for Windows paths.\n     *\n     * @return PathFactoryInterface The path factory used for Windows paths.\n     *\/\n    public function windowsFactory()\n    {\n        return $this->windowsFactory;\n    }\n\n    \/**\n     * Create a path representing the current working directory.\n     *\n     * @return AbsolutePathInterface A new path instance representing the\n     *     current working directory path.\n     *\/\n    public function createWorkingDirectoryPath()\n    {\n        return $this->factoryByPlatform()\n            ->create($this->isolator()->getcwd());\n    }\n\n    \/**\n     * Create a path representing the system temporary directory.\n     *\n     * @return AbsolutePathInterface A new path instance representing the system\n     *     default temporary directory path.\n     *\/\n    public function createTemporaryDirectoryPath()\n    {\n        return $this->factoryByPlatform()\n            ->create($this->isolator()->sys_get_temp_dir());\n    }\n\n    \/**\n     * Create a path representing a suitable for use as the location for a new\n     * temporary file or directory.\n     *\n     * This path is not guaranteed to be unused, but collisions are fairly\n     * unlikely.\n     *\n     * @param string|null $prefix A string to use as a prefix for the path name.\n     *\n     * @return AbsolutePathInterface A new path instance representing the new\n     *     temporary path.\n     *\/\n    public function createTemporaryPath($prefix = null)\n    {\n        if (null === $prefix) {\n            $prefix = '';\n        }\n\n        return $this->createTemporaryDirectoryPath()\n            ->joinAtoms($this->isolator()->uniqid($prefix, true));\n    }\n\n    \/**\n     * @return Isolator\n     *\/\n    protected function isolator()\n    {\n        return $this->isolator;\n    }\n\n    \/**\n     * @return PathFactoryInterface\n     *\/\n    protected function factoryByPlatform()\n    {\n        if ($this->isolator()->defined('PHP_WINDOWS_VERSION_BUILD')) {\n            return $this->windowsFactory();\n        }\n\n        return $this->posixFactory();\n    }\n\n    private $posixFactory;\n    private $windowsFactory;\n    private $isolator;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,26,3,3,26,3,3,null,26,26,26,26,null,null,null,null,null,null,null,null,17,null,null,null,null,null,null,null,null,null,13,null,null,null,null,null,null,null,null,null,null,5,5,null,null,null,null,null,null,null,null,null,null,10,10,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,6,4,4,null,6,6,null,null,null,null,null,null,null,19,null,null,null,null,null,null,null,19,8,null,null,11,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/FileSystem\/Factory\/FileSystemPathFactory.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\FileSystem\\Factory;\n\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * A path factory that produces file system paths by inspecting the supplied\n * string, and determining the most suitable path type to use.\n *\/\nclass FileSystemPathFactory extends AbstractFileSystemPathFactory\n{\n    \/**\n     * Creates a new path instance from its string representation.\n     *\n     * @param string $path The string representation of the path.\n     *\n     * @return PathInterface The newly created path instance.\n     *\/\n    public function create($path)\n    {\n        if (preg_match('\/^([a-zA-Z]):\/', $path)) {\n            return $this->windowsFactory()->create($path);\n        }\n\n        return $this->posixFactory()->create($path);\n    }\n\n    \/**\n     * Creates a new path instance from a set of path atoms.\n     *\n     * Unless otherwise specified, created paths will be absolute, and have no\n     * trailing separator.\n     *\n     * @param mixed<string> $atoms                The path atoms.\n     * @param boolean|null  $isAbsolute           True if the path is absolute.\n     * @param boolean|null  $hasTrailingSeparator True if the path has a\n     *     trailing separator.\n     *\n     * @return PathInterface                     The newly created path instance.\n     * @throws InvalidPathAtomExceptionInterface If any of the supplied atoms\n     *     are invalid.\n     *\/\n    public function createFromAtoms(\n        $atoms,\n        $isAbsolute = null,\n        $hasTrailingSeparator = null\n    ) {\n        return $this->posixFactory()->createFromAtoms(\n            $atoms,\n            $isAbsolute,\n            $hasTrailingSeparator\n        );\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,1,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,1,null,1,null,null]},{"name":"Eloquent\/Pathogen\/FileSystem\/Factory\/FileSystemPathFactoryInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\FileSystem\\Factory;\n\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\nuse Eloquent\\Pathogen\\Factory\\PathFactoryInterface;\n\n\/**\n * The interface implemented by path factories that deal with file system paths.\n *\/\ninterface FileSystemPathFactoryInterface extends PathFactoryInterface\n{\n    \/**\n     * Create a path representing the current working directory.\n     *\n     * @return AbsolutePathInterface A new path instance representing the\n     *     current working directory path.\n     *\/\n    public function createWorkingDirectoryPath();\n\n    \/**\n     * Create a path representing the system temporary directory.\n     *\n     * @return AbsolutePathInterface A new path instance representing the system\n     *     default temporary directory path.\n     *\/\n    public function createTemporaryDirectoryPath();\n\n    \/**\n     * Create a path representing a suitable for use as the location for a new\n     * temporary file or directory.\n     *\n     * This path is not guaranteed to be unused, but collisions are fairly\n     * unlikely.\n     *\n     * @param string|null $prefix A string to use as a prefix for the path name.\n     *\n     * @return AbsolutePathInterface A new path instance representing the new\n     *     temporary path.\n     *\/\n    public function createTemporaryPath($prefix = null);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/FileSystem\/Factory\/PlatformFileSystemPathFactory.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\FileSystem\\Factory;\n\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * A path factory that produces file system paths whose type correlates to the\n * platform on which the code is running.\n *\/\nclass PlatformFileSystemPathFactory extends AbstractFileSystemPathFactory\n{\n    \/**\n     * Creates a new path instance from its string representation.\n     *\n     * @param string $path The string representation of the path.\n     *\n     * @return PathInterface The newly created path instance.\n     *\/\n    public function create($path)\n    {\n        return $this->factoryByPlatform()->create($path);\n    }\n\n    \/**\n     * Creates a new path instance from a set of path atoms.\n     *\n     * Unless otherwise specified, created paths will be absolute, and have no\n     * trailing separator.\n     *\n     * @param mixed<string> $atoms                The path atoms.\n     * @param boolean|null  $isAbsolute           True if the path is absolute.\n     * @param boolean|null  $hasTrailingSeparator True if the path has a\n     *     trailing separator.\n     *\n     * @return PathInterface                     The newly created path instance.\n     * @throws InvalidPathAtomExceptionInterface If any of the supplied atoms\n     *     are invalid.\n     *\/\n    public function createFromAtoms(\n        $atoms,\n        $isAbsolute = null,\n        $hasTrailingSeparator = null\n    ) {\n        return $this->factoryByPlatform()->createFromAtoms(\n            $atoms,\n            $isAbsolute,\n            $hasTrailingSeparator\n        );\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,2,2,null,2,null,null]},{"name":"Eloquent\/Pathogen\/FileSystem\/Normalizer\/FileSystemPathNormalizer.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\FileSystem\\Normalizer;\n\nuse Eloquent\\Pathogen\\Normalizer\\PathNormalizer;\nuse Eloquent\\Pathogen\\Normalizer\\PathNormalizerInterface;\nuse Eloquent\\Pathogen\\PathInterface;\nuse Eloquent\\Pathogen\\Windows\\Normalizer\\WindowsPathNormalizer;\nuse Eloquent\\Pathogen\\Windows\\WindowsPathInterface;\n\n\/**\n * A path normalizer capable or normalizing any type of file system path.\n *\/\nclass FileSystemPathNormalizer implements PathNormalizerInterface\n{\n    \/**\n     * Construct a new file system path normalizer.\n     *\n     * @param PathNormalizerInterface|null $posixNormalizer The path normalizer\n     *     to use for Unix-style paths.\n     * @param PathNormalizerInterface|null $windowsNormalizer The path\n     *     normalizer to use for Windows paths.\n     *\/\n    public function __construct(\n        PathNormalizerInterface $posixNormalizer = null,\n        PathNormalizerInterface $windowsNormalizer = null\n    ) {\n        if (null === $posixNormalizer) {\n            $posixNormalizer = new PathNormalizer;\n        }\n        if (null === $windowsNormalizer) {\n            $windowsNormalizer = new WindowsPathNormalizer;\n        }\n\n        $this->posixNormalizer = $posixNormalizer;\n        $this->windowsNormalizer = $windowsNormalizer;\n    }\n\n    \/**\n     * Get the path normalizer used for Unix-style paths.\n     *\n     * @return PathNormalizerInterface The path normalizer used for Unix-style\n     *     paths.\n     *\/\n    public function posixNormalizer()\n    {\n        return $this->posixNormalizer;\n    }\n\n    \/**\n     * Get the path normalizer used for Windows paths.\n     *\n     * @return PathNormalizerInterface The path normalizer used for Windows\n     *     paths.\n     *\/\n    public function windowsNormalizer()\n    {\n        return $this->windowsNormalizer;\n    }\n\n    \/**\n     * Normalize the supplied path to it's most canonical form.\n     *\n     * @param PathInterface $path The path to normalize.\n     *\n     * @return PathInterface The normalized path.\n     *\/\n    public function normalize(PathInterface $path)\n    {\n        if ($path instanceof WindowsPathInterface) {\n            return $this->windowsNormalizer()->normalize($path);\n        }\n\n        return $this->posixNormalizer()->normalize($path);\n    }\n\n    private $posixNormalizer;\n    private $windowsNormalizer;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,1,1,4,1,1,null,4,4,4,null,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,null,null,2,1,null,null,1,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/FileSystem\/Resolver\/WorkingDirectoryResolver.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\FileSystem\\Resolver;\n\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\nuse Eloquent\\Pathogen\\FileSystem\\Factory\\FileSystemPathFactoryInterface;\nuse Eloquent\\Pathogen\\FileSystem\\Factory\\PlatformFileSystemPathFactory;\nuse Eloquent\\Pathogen\\Resolver\\BoundPathResolver;\nuse Eloquent\\Pathogen\\Resolver\\PathResolverInterface;\n\n\/**\n * A bound path resolver for resolving file system paths against the current\n * working directory.\n *\/\nclass WorkingDirectoryResolver extends BoundPathResolver\n{\n    \/**\n     * Construct a new working directory path resolver.\n     *\n     * @param AbsolutePathInterface|null          $workingDirectoryPath The working directory path.\n     * @param PathResolverInterface|null          $resolver             The path resolver to use.\n     * @param FileSystemPathFactoryInterface|null $factory              The path factory to use.\n     *\/\n    public function __construct(\n        AbsolutePathInterface $workingDirectoryPath = null,\n        PathResolverInterface $resolver = null,\n        FileSystemPathFactoryInterface $factory = null\n    ) {\n        if (null === $factory) {\n            $factory = new PlatformFileSystemPathFactory;\n        }\n\n        $this->factory = $factory;\n\n        if (null === $workingDirectoryPath) {\n            $workingDirectoryPath = $this->factory()\n                ->createWorkingDirectoryPath();\n        }\n\n        parent::__construct($workingDirectoryPath, $resolver);\n    }\n\n    \/**\n     * Get the path factory used by this resolver.\n     *\n     * @return FileSystemPathFactoryInterface The path factory.\n     *\/\n    public function factory()\n    {\n        return $this->factory;\n    }\n\n    private $factory;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,5,2,2,null,5,null,5,2,2,2,null,5,5,null,null,null,null,null,null,null,null,4,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Normalizer\/PathNormalizer.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Normalizer;\n\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\nuse Eloquent\\Pathogen\\Factory\\PathFactory;\nuse Eloquent\\Pathogen\\Factory\\PathFactoryInterface;\nuse Eloquent\\Pathogen\\PathInterface;\nuse Eloquent\\Pathogen\\RelativePathInterface;\n\n\/**\n * A path normalizer suitable for generic, Unix-style path instances.\n *\/\nclass PathNormalizer implements PathNormalizerInterface\n{\n    \/**\n     * Construct a new path normalizer.\n     *\n     * @param PathFactoryInterface|null $factory The path factory to use.\n     *\/\n    public function __construct(PathFactoryInterface $factory = null)\n    {\n        if (null === $factory) {\n            $factory = new PathFactory;\n        }\n\n        $this->factory = $factory;\n    }\n\n    \/**\n     * Get the path factory used by this normalizer.\n     *\n     * @return PathFactoryInterface The path factory.\n     *\/\n    public function factory()\n    {\n        return $this->factory;\n    }\n\n    \/**\n     * Normalize the supplied path to it's most canonical form.\n     *\n     * @param PathInterface $path The path to normalize.\n     *\n     * @return PathInterface The normalized path.\n     *\/\n    public function normalize(PathInterface $path)\n    {\n        if ($path instanceof AbsolutePathInterface) {\n            return $this->normalizeAbsolutePath($path);\n        }\n\n        return $this->normalizeRelativePath($path);\n    }\n\n    \/**\n     * @param AbsolutePathInterface $path\n     *\n     * @return AbsolutePathInterface\n     *\/\n    protected function normalizeAbsolutePath(AbsolutePathInterface $path)\n    {\n        return $this->factory()->createFromAtoms(\n            $this->normalizeAbsolutePathAtoms($path->atoms()),\n            true,\n            false\n        );\n    }\n\n    \/**\n     * @param RelativePathInterface $path\n     *\n     * @return RelativePathInterface\n     *\/\n    protected function normalizeRelativePath(RelativePathInterface $path)\n    {\n        return $this->factory()->createFromAtoms(\n            $this->normalizeRelativePathAtoms($path->atoms()),\n            false,\n            false\n        );\n    }\n\n    \/**\n     * @param array<string> $atoms\n     *\n     * @return array<string>\n     *\/\n    protected function normalizeAbsolutePathAtoms(array $atoms)\n    {\n        $resultingAtoms = array();\n        foreach ($atoms as $atom) {\n            if (PathInterface::PARENT_ATOM === $atom) {\n                array_pop($resultingAtoms);\n            } elseif (PathInterface::SELF_ATOM !== $atom) {\n                $resultingAtoms[] = $atom;\n            }\n        }\n\n        return $resultingAtoms;\n    }\n\n    \/**\n     * @param array<string> $atoms\n     *\n     * @return array<string>\n     *\/\n    protected function normalizeRelativePathAtoms(array $atoms)\n    {\n        $resultingAtoms = array();\n        $resultingAtomsCount = 0;\n        $numAtoms = count($atoms);\n\n        for ($i = 0; $i < $numAtoms; $i++) {\n            if (PathInterface::SELF_ATOM !== $atoms[$i]) {\n                $resultingAtoms[] = $atoms[$i];\n                $resultingAtomsCount++;\n            }\n\n            if (\n                $resultingAtomsCount > 1 &&\n                PathInterface::PARENT_ATOM === $resultingAtoms[$resultingAtomsCount - 1] &&\n                PathInterface::PARENT_ATOM !== $resultingAtoms[$resultingAtomsCount - 2]\n            ) {\n                array_splice($resultingAtoms, $resultingAtomsCount - 2, 2);\n                $resultingAtomsCount -= 2;\n            }\n        }\n\n        if (count($resultingAtoms) < 1) {\n            $resultingAtoms = array(PathInterface::SELF_ATOM);\n        }\n\n        return $resultingAtoms;\n    }\n\n    private $factory;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,50,50,50,null,50,50,null,null,null,null,null,null,null,null,50,null,null,null,null,null,null,null,null,null,null,null,50,19,null,null,31,null,null,null,null,null,null,null,null,null,19,19,19,null,19,null,null,null,null,null,null,null,null,null,31,31,31,null,31,null,null,null,null,null,null,null,null,null,19,19,19,13,19,15,15,19,null,19,null,null,null,null,null,null,null,null,null,31,31,31,null,31,31,29,29,29,null,null,31,31,19,31,15,15,15,31,null,31,4,4,null,31,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Normalizer\/PathNormalizerInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Normalizer;\n\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * The interface implemented by path normalizers.\n *\/\ninterface PathNormalizerInterface\n{\n    \/**\n     * Normalize the supplied path to it's most canonical form.\n     *\n     * @param PathInterface $path The path to normalize.\n     *\n     * @return PathInterface The normalized path.\n     *\/\n    public function normalize(PathInterface $path);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/PathInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen;\n\n\/**\n * The interface implemented by all Pathogen paths.\n *\/\ninterface PathInterface\n{\n    \/**\n     * Get the atoms of this path.\n     *\n     * For example, the path '\/foo\/bar' has the atoms 'foo' and 'bar'.\n     *\n     * @return array<integer,string> The atoms of this path as an array of\n     * strings.\n     *\/\n    public function atoms();\n\n    \/**\n     * Get a subset of the atoms of this path.\n     *\n     * @param integer      $index  The index of the first atom.\n     * @param integer|null $length The maximum number of atoms.\n     *\n     * @return array<integer,string> An array of strings representing the subset\n     *     of path atoms.\n     *\/\n    public function sliceAtoms($index, $length = null);\n\n    \/**\n     * Determine if this path has any atoms.\n     *\n     * @return boolean True if this path has at least one atom.\n     *\/\n    public function hasAtoms();\n\n    \/**\n     * Determine if this path has a trailing separator.\n     *\n     * @return boolean True if this path has a trailing separator.\n     *\/\n    public function hasTrailingSeparator();\n\n    \/**\n     * Generate a string representation of this path.\n     *\n     * @return string A string representation of this path.\n     *\/\n    public function string();\n\n    \/**\n     * Generate a string representation of this path.\n     *\n     * @return string A string representation of this path.\n     *\/\n    public function __toString();\n\n    \/**\n     * Get this path's name.\n     *\n     * @return string The last path atom if one exists, otherwise an empty\n     *     string.\n     *\/\n    public function name();\n\n    \/**\n     * Get this path's name atoms.\n     *\n     * For example, the path name 'foo.bar' has the atoms 'foo' and 'bar'.\n     *\n     * @return array<integer,string> The atoms of this path's name as an array\n     *     of strings.\n     *\/\n    public function nameAtoms();\n\n    \/**\n     * Get a subset of this path's name atoms.\n     *\n     * @param integer      $index  The index of the first atom.\n     * @param integer|null $length The maximum number of atoms.\n     *\n     * @return array<integer,string> An array of strings representing the subset\n     *     of path name atoms.\n     *\/\n    public function sliceNameAtoms($index, $length = null);\n\n    \/**\n     * Get this path's name, excluding the last extension.\n     *\n     * @return string The last atom of this path, excluding the last extension.\n     *     If this path has no atoms, an empty string is returned.\n     *\/\n    public function nameWithoutExtension();\n\n    \/**\n     * Get this path's name, excluding all extensions.\n     *\n     * @return string The last atom of this path, excluding any extensions. If\n     *     this path has no atoms, an empty string is returned.\n     *\/\n    public function namePrefix();\n\n    \/**\n     * Get all of this path's extensions.\n     *\n     * @return string|null The extensions of this path's last atom. If the last\n     *     atom has no extensions, or this path has no atoms, this method will\n     *     return null.\n     *\/\n    public function nameSuffix();\n\n    \/**\n     * Get this path's last extension.\n     *\n     * @return string|null The last extension of this path's last atom. If the\n     *     last atom has no extensions, or this path has no atoms, this method\n     *     will return null.\n     *\/\n    public function extension();\n\n    \/**\n     * Determine if this path has any extensions.\n     *\n     * @return boolean True if this path's last atom has any extensions.\n     *\/\n    public function hasExtension();\n\n    \/**\n     * Get the parent of this path a specified number of levels up.\n     *\n     * @param integer|null $numLevels The number of levels up. Defaults to 1.\n     *\n     * @return PathInterface The parent of this path $numLevels up.\n     *\/\n    public function parent($numLevels = null);\n\n    \/**\n     * Strips the trailing slash from this path.\n     *\n     * @return PathInterface A new path instance with the trailing slash removed\n     *     from this path. If this path has no trailing slash, the path is\n     *     returned unmodified.\n     *\/\n    public function stripTrailingSlash();\n\n    \/**\n     * Strips the last extension from this path.\n     *\n     * @return PathInterface A new path instance with the last extension removed\n     *     from this path. If this path has no extensions, the path is returned\n     *     unmodified.\n     *\/\n    public function stripExtension();\n\n    \/**\n     * Strips all extensions from this path.\n     *\n     * @return PathInterface A new path instance with all extensions removed\n     *     from this path. If this path has no extensions, the path is returned\n     *     unmodified.\n     *\/\n    public function stripNameSuffix();\n\n    \/**\n     * Joins one or more atoms to this path.\n     *\n     * @param string     $atom            A path atom to append.\n     * @param string,... $additionalAtoms Additional path atoms to append.\n     *\n     * @return PathInterface A new path with the supplied atom(s) suffixed to\n     *     this path.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If any joined atoms\n     *     are invalid.\n     *\/\n    public function joinAtoms($atom);\n\n    \/**\n     * Joins a sequence of atoms to this path.\n     *\n     * @param mixed<string> $atoms The path atoms to append.\n     *\n     * @return PathInterface A new path with the supplied sequence of atoms\n     *     suffixed to this path.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If any joined atoms\n     *     are invalid.\n     *\/\n    public function joinAtomSequence($atoms);\n\n    \/**\n     * Joins the supplied path to this path.\n     *\n     * @param RelativePathInterface $path The path whose atoms should be joined\n     *     to this path.\n     *\n     * @return PathInterface A new path with the supplied path suffixed to this\n     *     path.\n     *\/\n    public function join(RelativePathInterface $path);\n\n    \/**\n     * Adds a trailing slash to this path.\n     *\n     * @return PathInterface A new path instance with a trailing slash suffixed\n     *     to this path.\n     *\/\n    public function joinTrailingSlash();\n\n    \/**\n     * Joins one or more extensions to this path.\n     *\n     * @param string     $extension            An extension to append.\n     * @param string,... $additionalExtensions Additional extensions to append.\n     *\n     * @return PathInterface A new path instance with the supplied extensions\n     *     suffixed to this path.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If the suffixed\n     *     extensions cause the atom to be invalid.\n     *\/\n    public function joinExtensions($extension);\n\n    \/**\n     * Joins a sequence of extensions to this path.\n     *\n     * @param mixed<string> $extensions\n     *\n     * @return PathInterface A new path instance with the supplied extensions\n     *     suffixed to this path.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If the suffixed\n     *     extensions cause the atom to be invalid.\n     *\/\n    public function joinExtensionSequence($extensions);\n\n    \/**\n     * Suffixes this path's name with a supplied string.\n     *\n     * @param string $suffix The string to suffix to the path name.\n     *\n     * @return PathInterface A new path instance with the supplied string\n     *     suffixed to the last path atom.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If the suffix causes\n     *     the atom to be invalid.\n     *\/\n    public function suffixName($suffix);\n\n    \/**\n     * Prefixes this path's name with a supplied string.\n     *\n     * @param string $prefix The string to prefix to the path name.\n     *\n     * @return PathInterface A new path instance with the supplied string\n     *     prefixed to the last path atom.\n     * @throws Exception\\InvalidPathAtomExceptionInterface If the prefix causes\n     *     the atom to be invalid.\n     *\/\n    public function prefixName($prefix);\n\n    \/**\n     * Replace a section of this path with the supplied atom sequence.\n     *\n     * @param integer       $index       The start index of the replacement.\n     * @param mixed<string> $replacement The replacement atom sequence.\n     * @param integer|null  $length      The number of atoms to replace. If\n     *     $length is null, the entire remainder of the path will be replaced.\n     *\n     * @return PathInterface A new path instance that has a portion of this\n     *     path's atoms replaced with a different sequence of atoms.\n     *\/\n    public function replace($index, $replacement, $length = null);\n\n    \/**\n     * Replace this path's name.\n     *\n     * @param string $name The new path name.\n     *\n     * @return PathInterface A new path instance with the supplied name\n     *     replacing the existing one.\n     *\/\n    public function replaceName($name);\n\n    \/**\n     * Replace this path's name, but keep the last extension.\n     *\n     * @param string $nameWithoutExtension The replacement string.\n     *\n     * @return PathInterface A new path instance with the supplied name\n     *     replacing the portion of the existing name preceding the last\n     *     extension.\n     *\/\n    public function replaceNameWithoutExtension($nameWithoutExtension);\n\n    \/**\n     * Replace this path's name, but keep any extensions.\n     *\n     * @param string $namePrefix The replacement string.\n     *\n     * @return PathInterface A new path instance with the supplied name prefix\n     *     replacing the existing one.\n     *\/\n    public function replaceNamePrefix($namePrefix);\n\n    \/**\n     * Replace all of this path's extensions.\n     *\n     * @param string|null $nameSuffix The replacement string, or null to remove\n     *     all extensions.\n     *\n     * @return PathInterface A new path instance with the supplied name suffix\n     *     replacing the existing one.\n     *\/\n    public function replaceNameSuffix($nameSuffix);\n\n    \/**\n     * Replace this path's last extension.\n     *\n     * @param string|null $extension The replacement string, or null to remove\n     *     the last extension.\n     *\n     * @return PathInterface A new path instance with the supplied extension\n     *     replacing the existing one.\n     *\/\n    public function replaceExtension($extension);\n\n    \/**\n     * Replace a section of this path's name with the supplied name atom\n     * sequence.\n     *\n     * @param integer       $index       The start index of the replacement.\n     * @param mixed<string> $replacement The replacement name atom sequence.\n     * @param integer|null  $length      The number of atoms to replace. If\n     *     $length is null, the entire remainder of the path name will be\n     *     replaced.\n     *\n     * @return PathInterface A new path instance that has a portion of this\n     *     name's atoms replaced with a different sequence of atoms.\n     *\/\n    public function replaceNameAtoms($index, $replacement, $length = null);\n\n    \/**\n     * The character used to separate path atoms.\n     *\/\n    const ATOM_SEPARATOR = '\/';\n\n    \/**\n     * The character used to separate path name atoms.\n     *\/\n    const EXTENSION_SEPARATOR = '.';\n\n    \/**\n     * The atom used to represent 'parent'.\n     *\/\n    const PARENT_ATOM = '..';\n\n    \/**\n     * The atom used to represent 'self'.\n     *\/\n    const SELF_ATOM = '.';\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/RelativePath.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen;\n\n\/**\n * Represents a relative path.\n *\/\nclass RelativePath extends AbstractPath implements RelativePathInterface\n{\n    \/\/ Implementation of RelativePathInterface =================================\n\n    \/**\n     * Determine whether this path is the self path.\n     *\n     * The self path is a relative path with a single self atom (i.e. a dot\n     * '.').\n     *\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return boolean True if this path is the self path.\n     *\/\n    public function isSelf(\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    ) {\n        if (null === $normalizer) {\n            $normalizer = new Normalizer\\PathNormalizer;\n        }\n\n        $atoms = $normalizer->normalize($this)->atoms();\n\n        return 1 === count($atoms) && static::SELF_ATOM === $atoms[0];\n    }\n\n    \/\/ Implementation details ==================================================\n\n    \/**\n     * @param mixed<string> $atoms\n     *\n     * @return array<string>\n     *\/\n    protected function normalizeAtoms($atoms)\n    {\n        $atoms = parent::normalizeAtoms($atoms);\n        if (count($atoms) < 1) {\n            throw new Exception\\EmptyPathException;\n        }\n\n        return $atoms;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,8,8,8,null,8,null,8,null,null,null,null,null,null,null,null,null,null,null,422,378,2,null,null,376,null,null]},{"name":"Eloquent\/Pathogen\/RelativePathInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen;\n\n\/**\n * The interface implemented by relative paths.\n *\/\ninterface RelativePathInterface extends PathInterface\n{\n    \/**\n     * Determine whether this path is the self path.\n     *\n     * The self path is a relative path with a single self atom (i.e. a dot\n     * '.').\n     *\n     * @param Normalizer\\PathNormalizerInterface|null $normalizer The normalizer\n     *     to use when determining the result.\n     *\n     * @return boolean True if this path is the self path.\n     *\/\n    public function isSelf(\n        Normalizer\\PathNormalizerInterface $normalizer = null\n    );\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Resolver\/BoundPathResolver.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Resolver;\n\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * A path resolver that wraps another path resolver with a fixed base path.\n *\/\nclass BoundPathResolver implements BoundPathResolverInterface\n{\n    \/**\n     * Construct a new bound path resolver.\n     *\n     * @param AbsolutePathInterface      $basePath The base path.\n     * @param PathResolverInterface|null $resolver The path resolver to use.\n     *\/\n    public function __construct(\n        AbsolutePathInterface $basePath,\n        PathResolverInterface $resolver = null\n    ) {\n        if (null === $resolver) {\n            $resolver = new PathResolver;\n        }\n\n        $this->basePath = $basePath;\n        $this->resolver = $resolver;\n    }\n\n    \/**\n     * Get the base path used by this resolver.\n     *\n     * @returns AbsolutePathInterface The base path.\n     *\/\n    public function basePath()\n    {\n        return $this->basePath;\n    }\n\n    \/**\n     * Get the resolver used internally by this resolver.\n     *\n     * @returns PathResolverInterface The inner path resolver.\n     *\/\n    public function resolver()\n    {\n        return $this->resolver;\n    }\n\n    \/**\n     * Resolve a path against the base path.\n     *\n     * @param PathInterface $path The path to resolve.\n     *\n     * @return AbsolutePathInterface The resolved path.\n     *\/\n    public function resolve(PathInterface $path)\n    {\n        return $this->resolver()->resolve($this->basePath(), $path);\n    }\n\n    private $basePath;\n    private $resolver;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,2,2,null,4,4,4,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,4,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Resolver\/BoundPathResolverInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Resolver;\n\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * The interface implemented by path resolvers with a fixed base path.\n *\/\ninterface BoundPathResolverInterface\n{\n    \/**\n     * Resolve a path against the base path.\n     *\n     * @param PathInterface $path The path to resolve.\n     *\n     * @return AbsolutePathInterface The resolved path.\n     *\/\n    public function resolve(PathInterface $path);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Resolver\/NormalizingPathResolver.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Resolver;\n\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\nuse Eloquent\\Pathogen\\Normalizer\\PathNormalizer;\nuse Eloquent\\Pathogen\\Normalizer\\PathNormalizerInterface;\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * A path resolver that wraps another path resolver and automatically normalizes\n * the result.\n *\/\nclass NormalizingPathResolver implements PathResolverInterface\n{\n    \/**\n     * Construct a new normalizing path resolver.\n     *\n     * @param PathNormalizerInterface|null $normalizer The path normalizer to use.\n     * @param PathResolverInterface|null   $resolver   The path resolver to use.\n     *\/\n    public function __construct(\n        PathNormalizerInterface $normalizer = null,\n        PathResolverInterface $resolver = null\n    ) {\n        if (null === $normalizer) {\n            $normalizer = new PathNormalizer;\n        }\n        if (null === $resolver) {\n            $resolver = new PathResolver;\n        }\n\n        $this->normalizer = $normalizer;\n        $this->resolver = $resolver;\n    }\n\n    \/**\n     * Get the path normalizer used by this resolver.\n     *\n     * @return PathNormalizerInterface The path normalizer.\n     *\/\n    public function normalizer()\n    {\n        return $this->normalizer;\n    }\n\n    \/**\n     * Get the resolver used internally by this resolver.\n     *\n     * @returns PathResolverInterface The inner path resolver.\n     *\/\n    public function resolver()\n    {\n        return $this->resolver;\n    }\n\n    \/**\n     * Resolve a path against a given base path.\n     *\n     * @param AbsolutePathInterface $basePath The base path.\n     * @param PathInterface         $path     The path to resolve.\n     *\n     * @return AbsolutePathInterface The resolved path.\n     *\/\n    public function resolve(\n        AbsolutePathInterface $basePath,\n        PathInterface $path\n    ) {\n        return $this->normalizer()->normalize(\n            $this->resolver()->resolve($basePath, $path)\n        );\n    }\n\n    private $normalizer;\n    private $resolver;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,2,2,4,2,2,null,4,4,4,null,null,null,null,null,null,null,null,4,null,null,null,null,null,null,null,null,null,4,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,2,2,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Resolver\/PathResolver.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Resolver;\n\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * A path resolver suitable for resolving generic, Unix-style paths.\n *\/\nclass PathResolver implements PathResolverInterface\n{\n    \/**\n     * Resolve a path against a given base path.\n     *\n     * @param AbsolutePathInterface $basePath The base path.\n     * @param PathInterface         $path     The path to resolve.\n     *\n     * @return AbsolutePathInterface The resolved path.\n     *\/\n    public function resolve(\n        AbsolutePathInterface $basePath,\n        PathInterface $path\n    ) {\n        if ($path instanceof AbsolutePathInterface) {\n            return $path;\n        }\n\n        return $basePath->join($path);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,20,4,null,null,16,null,null]},{"name":"Eloquent\/Pathogen\/Resolver\/PathResolverInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Resolver;\n\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * The interface implemented by path resolvers.\n *\/\ninterface PathResolverInterface\n{\n    \/**\n     * Resolve a path against a given base path.\n     *\n     * @param AbsolutePathInterface $basePath The base path.\n     * @param PathInterface         $path     The path to resolve.\n     *\n     * @return AbsolutePathInterface The resolved path.\n     *\/\n    public function resolve(\n        AbsolutePathInterface $basePath,\n        PathInterface $path\n    );\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/AbsoluteWindowsPath.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows;\n\nuse Eloquent\\Pathogen\\AbsolutePath;\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\nuse Eloquent\\Pathogen\\Exception\\InvalidPathAtomCharacterException;\nuse Eloquent\\Pathogen\\Exception\\InvalidPathAtomExceptionInterface;\nuse Eloquent\\Pathogen\\Exception\\PathAtomContainsSeparatorException;\nuse Eloquent\\Pathogen\\Normalizer\\PathNormalizerInterface;\n\n\/**\n * Represents an absolute Windows path.\n *\/\nclass AbsoluteWindowsPath extends AbsolutePath implements\n    AbsoluteWindowsPathInterface\n{\n    \/**\n     * Construct a new path instance.\n     *\n     * @param mixed<string> $atoms The path atoms.\n     * @param string|null   $drive The drive specifier, or null if the path has\n     *     no drive specifier.\n     * @param boolean|null $hasTrailingSeparator True if this path has a\n     *     trailing separator.\n     *\n     * @throws Exception\\InvalidDriveSpecifierException If the drive specifier\n     *     is invalid.\n     * @throws InvalidPathAtomExceptionInterface If any of the supplied path\n     *     atoms are invalid.\n     *\/\n    public function __construct($atoms, $drive, $hasTrailingSeparator = null)\n    {\n        if (null !== $drive && !preg_match('\/^[a-zA-Z]$\/', $drive)) {\n            throw new Exception\\InvalidDriveSpecifierException($drive);\n        }\n\n        parent::__construct($atoms, $hasTrailingSeparator);\n\n        $this->drive = $drive;\n    }\n\n    \/\/ Implementation of AbsoluteWindowsPathInterface ==========================\n\n    \/**\n     * Get this path's drive specifier.\n     *\n     * @return string|null The drive specifier, or null if this path does not\n     *     have a drive specifier.\n     *\/\n    public function drive()\n    {\n        return $this->drive;\n    }\n\n    \/**\n     * Determine whether this path has a drive specifier.\n     *\n     * @return boolean True is this path has a drive specifier.\n     *\/\n    public function hasDrive()\n    {\n        return null !== $this->drive();\n    }\n\n    \/**\n     * Joins the supplied drive specifier to this path.\n     *\n     * @return string|null $drive The drive specifier to use, or null to remove\n     *     the drive specifier.\n     *\n     * @return AbsoluteWindowsPathInterface A new path instance with the\n     *     supplied drive specifier joined to this path.\n     *\/\n    public function joinDrive($drive)\n    {\n        return $this->createPathWithDrive(\n            $this->atoms(),\n            $drive,\n            false\n        );\n    }\n\n    \/\/ Implementation of PathInterface =========================================\n\n    \/**\n     * Generate a string representation of this path.\n     *\n     * @return string A string representation of this path.\n     *\/\n    public function string()\n    {\n        $drive = $this->drive();\n        if (null !== $drive) {\n            return\n                $drive .\n                ':' .\n                static::ATOM_SEPARATOR .\n                implode(static::ATOM_SEPARATOR, $this->atoms()) .\n                ($this->hasTrailingSeparator() ? static::ATOM_SEPARATOR : '')\n            ;\n        }\n\n        return\n            static::ATOM_SEPARATOR .\n            implode(static::ATOM_SEPARATOR, $this->atoms()) .\n            ($this->hasTrailingSeparator() ? static::ATOM_SEPARATOR : '')\n        ;\n    }\n\n    \/\/ Implementation of AbsolutePathInterface =================================\n\n    \/**\n     * Determine if this path is the direct parent of the supplied path.\n     *\n     * @param AbsolutePathInterface        $path       The child path.\n     * @param PathNormalizerInterface|null $normalizer The normalizer to use\n     *     when determining the result.\n     *\n     * @return boolean True if this path is the direct parent of the supplied\n     *     path.\n     *\/\n    public function isParentOf(\n        AbsolutePathInterface $path,\n        PathNormalizerInterface $normalizer = null\n    ) {\n        if (null == $normalizer) {\n            $normalizer = new Normalizer\\WindowsPathNormalizer;\n        }\n\n        if (!$this->driveSpecifiersMatch($this, $path)) {\n            return false;\n        }\n\n        return parent::isParentOf($path, $normalizer);\n    }\n\n    \/**\n     * Determine if this path is an ancestor of the supplied path.\n     *\n     * @param AbsolutePathInterface        $path       The child path.\n     * @param PathNormalizerInterface|null $normalizer The normalizer to use\n     *     when determining the result.\n     *\n     * @return boolean True if this path is an ancestor of the supplied path.\n     *\/\n    public function isAncestorOf(\n        AbsolutePathInterface $path,\n        PathNormalizerInterface $normalizer = null\n    ) {\n        if (null == $normalizer) {\n            $normalizer = new Normalizer\\WindowsPathNormalizer;\n        }\n\n        if (!$this->driveSpecifiersMatch($this, $path)) {\n            return false;\n        }\n\n        return parent::isAncestorOf($path, $normalizer);\n    }\n\n    \/**\n     * Determine the shortest path from the supplied path to this path.\n     *\n     * For example, given path A equal to '\/foo\/bar', and path B equal to\n     * '\/foo\/baz', A relative to B would be '..\/bar'.\n     *\n     * @param AbsolutePathInterface $path The path that the generated path will\n     *     be relative to.\n     * @param PathNormalizerInterface|null $normalizer The normalizer to use\n     *     when determining the result.\n     *\n     * @return RelativePathInterface A relative path from the supplied path to\n     *     this path.\n     *\/\n    public function relativeTo(\n        AbsolutePathInterface $path,\n        PathNormalizerInterface $normalizer = null\n    ) {\n        if (null == $normalizer) {\n            $normalizer = new Normalizer\\WindowsPathNormalizer;\n        }\n\n        $thisDrive = $this->normalizePathDriveSpecifier($this);\n        $pathDrive = $this->normalizePathDriveSpecifier($path);\n        if ($thisDrive !== $pathDrive) {\n            throw new Exception\\DriveMismatchException(\n                $thisDrive,\n                $pathDrive\n            );\n        }\n\n        return parent::relativeTo($path, $normalizer);\n    }\n\n    \/\/ Implementation details ==================================================\n\n    \/**\n     * @param string $atom\n     *\/\n    protected function validateAtom($atom)\n    {\n        parent::validateAtom($atom);\n\n        if (false !== strpos($atom, '\\\\')) {\n            throw new PathAtomContainsSeparatorException($atom);\n        } elseif (preg_match('\/([\\x00-\\x1F<>:\"|?*])\/', $atom, $matches)) {\n            throw new InvalidPathAtomCharacterException($atom, $matches[1]);\n        }\n    }\n\n    \/**\n     * @param AbsolutePathInterface $path\n     *\n     * @return string|null\n     *\/\n    protected function normalizePathDriveSpecifier(AbsolutePathInterface $path)\n    {\n        if ($path instanceof AbsoluteWindowsPathInterface) {\n            $drive = $path->drive();\n            if (null !== $drive) {\n                $drive = strtoupper($drive);\n            }\n\n            return $drive;\n        }\n\n        return null;\n    }\n\n    \/**\n     * @param AbsolutePathInterface $left\n     * @param AbsolutePathInterface $right\n     *\n     * @return boolean\n     *\/\n    protected function driveSpecifiersMatch(\n        AbsolutePathInterface $left,\n        AbsolutePathInterface $right\n    ) {\n        $leftDrive = $this->normalizePathDriveSpecifier($left);\n        $rightDrive = $this->normalizePathDriveSpecifier($right);\n\n        return $leftDrive === $rightDrive;\n    }\n\n    \/**\n     * @param mixed<string> $atoms\n     * @param boolean       $isAbsolute\n     * @param boolean|null  $hasTrailingSeparator\n     *\n     * @return PathInterface\n     *\/\n    protected function createPath(\n        $atoms,\n        $isAbsolute,\n        $hasTrailingSeparator = null\n    ) {\n        if ($isAbsolute) {\n            return $this->createPathWithDrive(\n                $atoms,\n                $this->drive(),\n                $hasTrailingSeparator\n            );\n        }\n\n        return new RelativeWindowsPath($atoms, $hasTrailingSeparator);\n    }\n\n    \/**\n     * @param mixed<string> $atoms\n     * @param string|null   $drive\n     * @param boolean|null  $hasTrailingSeparator\n     *\n     * @return PathInterface\n     *\/\n    protected function createPathWithDrive(\n        $atoms,\n        $drive,\n        $hasTrailingSeparator = null\n    ) {\n        return new static(\n            $atoms,\n            $drive,\n            $hasTrailingSeparator\n        );\n    }\n\n    private $drive;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,454,2,null,null,452,null,410,410,null,null,null,null,null,null,null,null,null,null,null,364,null,null,null,null,null,null,null,null,null,14,null,null,null,null,null,null,null,null,null,null,null,null,null,4,4,4,null,4,null,null,null,null,null,null,null,null,null,null,null,230,230,null,null,115,115,115,115,115,null,null,null,115,115,115,115,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,20,20,20,null,20,2,null,null,18,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,20,20,20,null,20,2,null,null,18,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,19,19,19,null,19,19,19,2,2,null,2,null,null,17,null,null,null,null,null,null,null,null,null,436,null,434,4,433,117,null,394,null,null,null,null,null,null,null,null,39,39,39,22,22,null,39,null,null,3,null,null,null,null,null,null,null,null,null,null,null,null,20,20,null,20,null,null,null,null,null,null,null,null,null,null,null,null,null,null,333,316,316,316,null,316,null,null,17,null,null,null,null,null,null,null,null,null,null,null,null,null,null,320,320,320,null,320,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/AbsoluteWindowsPathInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows;\n\nuse Eloquent\\Pathogen\\AbsolutePathInterface;\n\n\/**\n * The interface implemented by absolute Windows paths.\n *\/\ninterface AbsoluteWindowsPathInterface extends\n    AbsolutePathInterface,\n    WindowsPathInterface\n{\n    \/**\n     * Get this path's drive specifier.\n     *\n     * @return string|null The drive specifier, or null if this path does not\n     *     have a drive specifier.\n     *\/\n    public function drive();\n\n    \/**\n     * Determine whether this path has a drive specifier.\n     *\n     * @return boolean True is this path has a drive specifier.\n     *\/\n    public function hasDrive();\n\n    \/**\n     * Joins the supplied drive specifier to this path.\n     *\n     * @return string|null $drive The drive specifier to use, or null to remove\n     *     the drive specifier.\n     *\n     * @return AbsoluteWindowsPathInterface A new path instance with the\n     *     supplied drive specifier joined to this path.\n     *\/\n    public function joinDrive($drive);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/Exception\/DriveMismatchException.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows\\Exception;\n\nuse Exception;\n\n\/**\n * The drive specifiers of the two paths do not match.\n *\/\nfinal class DriveMismatchException extends Exception\n{\n    \/**\n     * Constructs a new drive specifier mismatch exception.\n     *\n     * @param string         $leftDrive  The left-hand drive specifier.\n     * @param string         $rightDrive The right-hand drive specifier.\n     * @param Exception|null $previous   The previous exception, if available.\n     *\/\n    public function __construct(\n        $leftDrive,\n        $rightDrive,\n        Exception $previous = null\n    ) {\n        $this->leftDrive = $leftDrive;\n        $this->rightDrive = $rightDrive;\n\n        parent::__construct(\n            sprintf(\n                'Drive specifiers %s and %s do not match.',\n                var_export($leftDrive, true),\n                var_export($rightDrive, true)\n            ),\n            0,\n            $previous\n        );\n    }\n\n    \/**\n     * Get the left-hand drive specifier.\n     *\n     * @return string The left-hand drive specifier.\n     *\/\n    public function leftDrive()\n    {\n        return $this->leftDrive;\n    }\n\n    \/**\n     * Get the right-hand drive specifier.\n     *\n     * @return string The right-hand drive specifier.\n     *\/\n    public function rightDrive()\n    {\n        return $this->rightDrive;\n    }\n\n    private $leftDrive;\n    private $rightDrive;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,null,1,1,1,1,1,1,1,null,1,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/Exception\/InvalidDriveSpecifierException.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows\\Exception;\n\nuse Exception;\n\n\/**\n * The provided drive specifier is invalid.\n *\/\nfinal class InvalidDriveSpecifierException extends Exception\n{\n    \/**\n     * Constructs a new invalid drive specifier exception.\n     *\n     * @param string         $drive    The invalid drive specifier.\n     * @param Exception|null $previous The previous exception, if available.\n     *\/\n    public function __construct($drive, Exception $previous = null)\n    {\n        $this->drive = $drive;\n\n        parent::__construct(\n            sprintf('Invalid drive specifier %s.', var_export($drive, true)),\n            0,\n            $previous\n        );\n    }\n\n    \/**\n     * Get the invalid drive specifier.\n     *\n     * @return string The invalid drive specifier.\n     *\/\n    public function drive()\n    {\n        return $this->drive;\n    }\n\n    private $drive;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,1,1,null,null,null,null,null,null,null,null,1,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/Factory\/WindowsPathFactory.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows\\Factory;\n\nuse Eloquent\\Pathogen\\Exception\\InvalidPathAtomExceptionInterface;\nuse Eloquent\\Pathogen\\Exception\\InvalidPathStateException;\nuse Eloquent\\Pathogen\\Factory\\PathFactory;\nuse Eloquent\\Pathogen\\Factory\\PathFactoryInterface;\nuse Eloquent\\Pathogen\\PathInterface;\nuse Eloquent\\Pathogen\\Windows\\AbsoluteWindowsPath;\nuse Eloquent\\Pathogen\\Windows\\RelativeWindowsPath;\n\n\/**\n * A path factory that creates Windows path instances.\n *\/\nclass WindowsPathFactory extends PathFactory implements\n    WindowsPathFactoryInterface\n{\n    \/**\n     * Construct a new Windows path factory.\n     *\n     * @param string $defaultDrive The default drive specifier to use when none\n     *     is specified, or null to leave the drive specifier empty.\n     *\/\n    public function __construct($defaultDrive = null)\n    {\n        $this->defaultDrive = $defaultDrive;\n    }\n\n    \/**\n     * Get the default drive specifier.\n     *\n     * @return string|null The default drive specifier.\n     *\/\n    public function defaultDrive()\n    {\n        return $this->defaultDrive;\n    }\n\n    \/\/ Implementation of PathFactoryInterface ==================================\n\n    \/**\n     * Creates a new path instance from its string representation.\n     *\n     * @param string $path The string representation of the path.\n     *\n     * @return PathInterface The newly created path instance.\n     *\/\n    public function create($path)\n    {\n        $isAbsolute = false;\n        $drive = null;\n        $hasTrailingSeparator = false;\n\n        $atoms = preg_split('~[\/\\\\\\\\]~', $path);\n        if (preg_match('\/^([a-zA-Z]):$\/', $atoms[0], $matches)) {\n            $isAbsolute = true;\n            $drive = $matches[1];\n            array_shift($atoms);\n        }\n        $numAtoms = count($atoms);\n\n        if ($numAtoms > 1) {\n            if ('' === $atoms[0]) {\n                $isAbsolute = true;\n                array_shift($atoms);\n                --$numAtoms;\n            }\n\n            if ('' === $atoms[$numAtoms - 1]) {\n                $hasTrailingSeparator = !$isAbsolute || $numAtoms > 1;\n                array_pop($atoms);\n                --$numAtoms;\n            }\n        }\n\n        foreach ($atoms as $index => $atom) {\n            if ('' === $atom) {\n                array_splice($atoms, $index, 1);\n                --$numAtoms;\n            }\n        }\n\n        return $this->createFromDriveAndAtoms(\n            $atoms,\n            $drive,\n            $isAbsolute,\n            $hasTrailingSeparator\n        );\n    }\n\n    \/**\n     * Creates a new path instance from a set of path atoms.\n     *\n     * Unless otherwise specified, created paths will be absolute, and have no\n     * trailing separator.\n     *\n     * @param mixed<string> $atoms                The path atoms.\n     * @param boolean|null  $isAbsolute           True if the path is absolute.\n     * @param boolean|null  $hasTrailingSeparator True if the path has a\n     *     trailing separator.\n     *\n     * @return PathInterface                     The newly created path instance.\n     * @throws InvalidPathAtomExceptionInterface If any of the supplied atoms\n     *     are invalid.\n     *\/\n    public function createFromAtoms(\n        $atoms,\n        $isAbsolute = null,\n        $hasTrailingSeparator = null\n    ) {\n        return $this->createFromDriveAndAtoms(\n            $atoms,\n            $isAbsolute ? $this->defaultDrive() : null,\n            $isAbsolute,\n            $hasTrailingSeparator\n        );\n    }\n\n    \/\/ Implementation of WindowsPathFactoryInterface ===========================\n\n    \/**\n     * Creates a new path instance from a set of path atoms and a drive\n     * specifier.\n     *\n     * Unless otherwise specified, created paths will be absolute, and have no\n     * trailing separator.\n     *\n     * @param mixed<string> $atoms                The path atoms.\n     * @param string|null   $drive                The drive specifier.\n     * @param boolean|null  $isAbsolute           True if the path is absolute.\n     * @param boolean|null  $hasTrailingSeparator True if the path has a\n     *     trailing separator.\n     *\n     * @return PathInterface                     The newly created path instance.\n     * @throws InvalidPathAtomExceptionInterface If any of the supplied atoms\n     *     are invalid.\n     *\/\n    public function createFromDriveAndAtoms(\n        $atoms,\n        $drive,\n        $isAbsolute = null,\n        $hasTrailingSeparator = null\n    ) {\n        if (!$isAbsolute && null !== $drive) {\n            throw new InvalidPathStateException(\n                \"Path cannot be relative and have a drive specifier.\"\n            );\n        }\n\n        if ($isAbsolute) {\n            return new AbsoluteWindowsPath(\n                $atoms,\n                $drive,\n                $hasTrailingSeparator\n            );\n        }\n\n        return new RelativeWindowsPath($atoms, $hasTrailingSeparator);\n    }\n\n    private $defaultDrive;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,73,73,null,null,null,null,null,null,null,null,19,null,null,null,null,null,null,null,null,null,null,null,null,null,23,23,23,null,23,23,9,9,9,9,23,null,23,20,9,9,9,9,null,20,9,9,9,9,20,null,23,21,8,8,8,23,null,23,23,23,23,null,23,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,23,23,23,23,null,23,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,70,1,null,1,null,null,69,51,51,51,null,51,null,null,18,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/Factory\/WindowsPathFactoryInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows\\Factory;\n\nuse Eloquent\\Pathogen\\Exception\\InvalidPathAtomExceptionInterface;\nuse Eloquent\\Pathogen\\Factory\\PathFactoryInterface;\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * The interface implemented by path factories that create Windows paths.\n *\/\ninterface WindowsPathFactoryInterface extends PathFactoryInterface\n{\n    \/**\n     * Creates a new path instance from a set of path atoms and a drive\n     * specifier.\n     *\n     * Unless otherwise specified, created paths will be absolute, and have no\n     * trailing separator.\n     *\n     * @param mixed<string> $atoms                The path atoms.\n     * @param string|null   $drive                The drive specifier.\n     * @param boolean|null  $isAbsolute           True if the path is absolute.\n     * @param boolean|null  $hasTrailingSeparator True if the path has a\n     *     trailing separator.\n     *\n     * @return PathInterface                     The newly created path instance.\n     * @throws InvalidPathAtomExceptionInterface If any of the supplied atoms\n     *     are invalid.\n     *\/\n    public function createFromDriveAndAtoms(\n        $atoms,\n        $drive,\n        $isAbsolute = null,\n        $hasTrailingSeparator = null\n    );\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/Normalizer\/WindowsPathNormalizer.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows\\Normalizer;\n\nuse Eloquent\\Pathogen\\PathInterface;\nuse Eloquent\\Pathogen\\Normalizer\\PathNormalizer;\nuse Eloquent\\Pathogen\\Windows\\AbsoluteWindowsPathInterface;\nuse Eloquent\\Pathogen\\Windows\\Factory\\WindowsPathFactory;\nuse Eloquent\\Pathogen\\Windows\\Factory\\WindowsPathFactoryInterface;\n\n\/**\n * A path normalizer suitable for normalizing Windows paths.\n *\/\nclass WindowsPathNormalizer extends PathNormalizer\n{\n    \/**\n     * Construct a new Windows path normalizer.\n     *\n     * @param WindowsPathFactoryInterface|null $factory The path factory to use.\n     *\/\n    public function __construct(WindowsPathFactoryInterface $factory = null)\n    {\n        if (null === $factory) {\n            $factory = new WindowsPathFactory;\n        }\n\n        parent::__construct($factory);\n    }\n\n    \/**\n     * Normalize the supplied path to it's most canonical form.\n     *\n     * @param PathInterface $path The path to normalize.\n     *\n     * @return PathInterface The normalized path.\n     *\/\n    public function normalize(PathInterface $path)\n    {\n        if ($path instanceof AbsoluteWindowsPathInterface) {\n            return $this->normalizeAbsoluteWindowsPath($path);\n        }\n\n        return parent::normalize($path);\n    }\n\n    \/**\n     * @param AbsoluteWindowsPathInterface $path\n     *\n     * @return AbsoluteWindowsPathInterface\n     *\/\n    protected function normalizeAbsoluteWindowsPath(\n        AbsoluteWindowsPathInterface $path\n    ) {\n        return $this->factory()->createFromDriveAndAtoms(\n            $this->normalizeAbsolutePathAtoms($path->atoms()),\n            $this->normalizeDriveSpecifier($path->drive()),\n            true,\n            false\n        );\n    }\n\n    \/**\n     * @param string|null $drive\n     *\n     * @return string|null\n     *\/\n    protected function normalizeDriveSpecifier($drive)\n    {\n        if (null === $drive) {\n            return null;\n        }\n\n        return strtoupper($drive);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,66,66,66,null,66,66,null,null,null,null,null,null,null,null,null,null,66,35,null,null,31,null,null,null,null,null,null,null,null,null,null,35,35,35,35,null,35,null,null,null,null,null,null,null,null,null,35,17,null,null,18,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/RelativeWindowsPath.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows;\n\nuse Eloquent\\Pathogen\\RelativePath;\nuse Eloquent\\Pathogen\\Exception\\InvalidPathAtomCharacterException;\nuse Eloquent\\Pathogen\\Exception\\PathAtomContainsSeparatorException;\n\n\/**\n * Represents a relative Windows path.\n *\/\nclass RelativeWindowsPath extends RelativePath implements\n    RelativeWindowsPathInterface\n{\n    \/**\n     * @param string $atom\n     *\/\n    protected function validateAtom($atom)\n    {\n        parent::validateAtom($atom);\n\n        if (false !== strpos($atom, '\\\\')) {\n            throw new PathAtomContainsSeparatorException($atom);\n        } elseif (preg_match('\/([\\x00-\\x1F<>:\"|?*])\/', $atom, $matches)) {\n            throw new InvalidPathAtomCharacterException($atom, $matches[1]);\n        }\n    }\n\n    \/**\n     * @param mixed<string> $atoms\n     * @param boolean       $isAbsolute\n     * @param boolean|null  $hasTrailingSeparator\n     *\n     * @return PathInterface\n     *\/\n    protected function createPath(\n        $atoms,\n        $isAbsolute,\n        $hasTrailingSeparator = null\n    ) {\n        return new static($atoms, $hasTrailingSeparator);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,268,null,266,3,265,117,null,226,null,null,null,null,null,null,null,null,null,null,null,null,null,193,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/RelativeWindowsPathInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows;\n\nuse Eloquent\\Pathogen\\RelativePathInterface;\n\n\/**\n * The interface implemented by relative Windows paths.\n *\/\ninterface RelativeWindowsPathInterface extends\n    RelativePathInterface,\n    WindowsPathInterface\n{\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Eloquent\/Pathogen\/Windows\/WindowsPathInterface.php","source":"<?php\n\n\/*\n * This file is part of the Pathogen package.\n *\n * Copyright \u00a9 2013 Erin Millard\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/\n\nnamespace Eloquent\\Pathogen\\Windows;\n\nuse Eloquent\\Pathogen\\PathInterface;\n\n\/**\n * The interface implemented by all Windows paths.\n *\/\ninterface WindowsPathInterface extends PathInterface\n{\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}]}